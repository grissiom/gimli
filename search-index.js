var searchIndex = {};
searchIndex["arrayvec"] = {"doc":"**arrayvec** provides the types `ArrayVec` and `ArrayString`:\narray-backed vector and string types, which store their contents inline.","items":[[8,"RangeArgument","arrayvec","**IndexRange** is implemented by Rust&#39;s built-in range types, produced\nby range syntax like `..`, `a..`, `..b` or `c..d`.",null,null],[11,"start","","Start index (inclusive)",0,null],[11,"end","","End index (exclusive)",0,null],[3,"ArrayString","","A string with a fixed capacity.",null,null],[3,"ArrayVec","","A vector with a fixed capacity.",null,null],[3,"IntoIter","","By-value iterator for `ArrayVec`.",null,null],[3,"Drain","","A draining iterator for `ArrayVec`.",null,null],[3,"CapacityError","","Error value indicating insufficient capacity",null,null],[11,"new","","Create a new empty `ArrayString`.",1,{"inputs":[],"output":{"name":"arraystring"}}],[11,"from","","Create a new `ArrayString` from a `str`.",1,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"capacity","","Return the capacity of the `ArrayString`.",1,null],[11,"is_full","","Return if the `ArrayString` is completely filled.",1,null],[11,"push","","Adds the given char to the end of the string.",1,null],[11,"push_str","","Adds the given string slice to the end of the string.",1,null],[11,"clear","","Make the string empty.",1,null],[11,"set_len","","Set the strings&#39;s length.",1,null],[11,"as_str","","Return a string slice of the whole `ArrayString`.",1,null],[11,"deref","","",1,null],[11,"deref_mut","","",1,null],[11,"eq","","",1,null],[11,"eq","","",1,null],[11,"hash","","",1,null],[11,"borrow","","",1,null],[11,"as_ref","","",1,null],[11,"fmt","","",1,null],[11,"fmt","","",1,null],[11,"write_char","","",1,null],[11,"write_str","","",1,null],[11,"clone","","",1,null],[11,"clone_from","","",1,null],[8,"Array","","Trait for fixed size arrays.",null,null],[16,"Item","","The array&#39;s element type",2,null],[11,"drop","","",3,null],[11,"new","","Create a new empty `ArrayVec`.",3,{"inputs":[],"output":{"name":"arrayvec"}}],[11,"len","","Return the number of elements in the `ArrayVec`.",3,null],[11,"capacity","","Return the capacity of the `ArrayVec`.",3,null],[11,"is_full","","Return if the `ArrayVec` is completely filled.",3,null],[11,"push","","Push `element` to the end of the vector.",3,null],[11,"insert","","Insert `element` in position `index`.",3,null],[11,"pop","","Remove the last element in the vector.",3,null],[11,"swap_remove","","Remove the element at `index` and swap the last element into its place.",3,null],[11,"remove","","Remove the element at `index` and shift down the following elements.",3,null],[11,"clear","","Remove all elements in the vector.",3,null],[11,"retain","","Retains only the elements specified by the predicate.",3,null],[11,"set_len","","Set the vector&#39;s length without dropping or moving out elements",3,null],[11,"drain","","Create a draining iterator that removes the specified range in the vector\nand yields the removed items from start to end. The element range is\nremoved even if the iterator is not consumed until the end.",3,null],[11,"into_inner","","Return the inner fixed size array, if it is full to its capacity.",3,null],[11,"dispose","","Dispose of `self` without the overwriting that is needed in Drop.",3,null],[11,"as_slice","","Return a slice containing all elements of the vector.",3,null],[11,"as_mut_slice","","Return a mutable slice containing all elements of the vector.",3,null],[11,"deref","","",3,null],[11,"deref_mut","","",3,null],[11,"from","","",3,{"inputs":[{"name":"a"}],"output":{"name":"self"}}],[11,"into_iter","","",3,null],[11,"next","","",4,null],[11,"size_hint","","",4,null],[11,"next_back","","",4,null],[11,"drop","","",4,null],[11,"next","","",5,null],[11,"size_hint","","",5,null],[11,"next_back","","",5,null],[11,"drop","","",5,null],[11,"extend","","",3,null],[11,"from_iter","","",3,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"clone","","",3,null],[11,"clone_from","","",3,null],[11,"hash","","",3,null],[11,"eq","","",3,null],[11,"eq","","",3,null],[11,"borrow","","",3,null],[11,"borrow_mut","","",3,null],[11,"as_ref","","",3,null],[11,"as_mut","","",3,null],[11,"fmt","","",3,null],[11,"default","","",3,{"inputs":[],"output":{"name":"arrayvec"}}],[11,"partial_cmp","","",3,null],[11,"lt","","",3,null],[11,"le","","",3,null],[11,"ge","","",3,null],[11,"gt","","",3,null],[11,"cmp","","",3,null],[11,"write","","",3,null],[11,"flush","","",3,null],[11,"clone","","",6,null],[11,"cmp","","",6,null],[11,"eq","","",6,null],[11,"ne","","",6,null],[11,"partial_cmp","","",6,null],[11,"lt","","",6,null],[11,"le","","",6,null],[11,"gt","","",6,null],[11,"ge","","",6,null],[11,"element","","Extract the overflowing element",6,null],[11,"simplify","","Convert into a `CapacityError` that does not carry an element.",6,null],[11,"description","","",6,null],[11,"fmt","","",6,null],[11,"fmt","","",6,null]],"paths":[[8,"RangeArgument"],[3,"ArrayString"],[8,"Array"],[3,"ArrayVec"],[3,"IntoIter"],[3,"Drain"],[3,"CapacityError"]]};
searchIndex["byteorder"] = {"doc":"This crate provides convenience methods for encoding and decoding numbers\nin either big-endian or little-endian order.","items":[[4,"BigEndian","byteorder","Defines big-endian serialization.",null,null],[4,"LittleEndian","","Defines little-endian serialization.",null,null],[6,"NetworkEndian","","Defines network byte order serialization.",null,null],[6,"NativeEndian","","Defines system native-endian serialization.",null,null],[8,"ReadBytesExt","","Extends `Read` with methods for reading numbers. (For `std::io`.)",null,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,null],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,null],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,null],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,null],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,null],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,null],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,null],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,null],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",0,null],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from\nthe underlying reader.",0,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from\nthe underlying reader.",0,null],[8,"WriteBytesExt","","Extends `Write` with methods for writing numbers. (For `std::io`.)",null,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,null],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,null],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,null],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,null],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,null],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,null],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,null],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,null],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,null],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to\nthe underlying writer.",1,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to\nthe underlying writer.",1,null],[8,"ByteOrder","","ByteOrder describes types that can serialize integers as bytes.",null,null],[10,"read_u16","","Reads an unsigned 16 bit integer from `buf`.",2,null],[10,"read_u32","","Reads an unsigned 32 bit integer from `buf`.",2,null],[10,"read_u64","","Reads an unsigned 64 bit integer from `buf`.",2,null],[10,"read_uint","","Reads an unsigned n-bytes integer from `buf`.",2,null],[10,"write_u16","","Writes an unsigned 16 bit integer `n` to `buf`.",2,null],[10,"write_u32","","Writes an unsigned 32 bit integer `n` to `buf`.",2,null],[10,"write_u64","","Writes an unsigned 64 bit integer `n` to `buf`.",2,null],[10,"write_uint","","Writes an unsigned integer `n` to `buf` using only `nbytes`.",2,null],[11,"read_i16","","Reads a signed 16 bit integer from `buf`.",2,null],[11,"read_i32","","Reads a signed 32 bit integer from `buf`.",2,null],[11,"read_i64","","Reads a signed 64 bit integer from `buf`.",2,null],[11,"read_int","","Reads a signed n-bytes integer from `buf`.",2,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number.",2,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number.",2,null],[11,"write_i16","","Writes a signed 16 bit integer `n` to `buf`.",2,null],[11,"write_i32","","Writes a signed 32 bit integer `n` to `buf`.",2,null],[11,"write_i64","","Writes a signed 64 bit integer `n` to `buf`.",2,null],[11,"write_int","","Writes a signed integer `n` to `buf` using only `nbytes`.",2,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number.",2,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number.",2,null],[11,"read_u16","","",3,null],[11,"read_u32","","",3,null],[11,"read_u64","","",3,null],[11,"read_uint","","",3,null],[11,"write_u16","","",3,null],[11,"write_u32","","",3,null],[11,"write_u64","","",3,null],[11,"write_uint","","",3,null],[11,"read_u16","","",4,null],[11,"read_u32","","",4,null],[11,"read_u64","","",4,null],[11,"read_uint","","",4,null],[11,"write_u16","","",4,null],[11,"write_u32","","",4,null],[11,"write_u64","","",4,null],[11,"write_uint","","",4,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,null],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,null],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,null],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,null],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,null],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,null],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,null],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,null],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",0,null],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from\nthe underlying reader.",0,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from\nthe underlying reader.",0,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,null],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,null],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,null],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,null],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,null],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,null],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,null],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,null],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,null],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to\nthe underlying writer.",1,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to\nthe underlying writer.",1,null]],"paths":[[8,"ReadBytesExt"],[8,"WriteBytesExt"],[8,"ByteOrder"],[4,"BigEndian"],[4,"LittleEndian"]]};
searchIndex["fallible_iterator"] = {"doc":"&quot;Fallible&quot; iterators.","items":[[3,"AndThen","fallible_iterator","An iterator which applies a fallible transform to the elements of the\nunderlying iterator.",null,null],[3,"Chain","","An iterator which yields the elements of one iterator followed by another.",null,null],[3,"Cloned","","An iterator which clones the elements of the underlying iterator.",null,null],[3,"Convert","","A fallible iterator that wraps a normal iterator over `Result`s.",null,null],[3,"Enumerate","","An iterator that yields the iteration count as well as the values of the\nunderlying iterator.",null,null],[3,"Filter","","An iterator which uses a predicate to determine which values of the\nunderlying iterator should be yielded.",null,null],[3,"FilterMap","","An iterator which both filters and maps the values of the underlying\niterator.",null,null],[3,"Fuse","","An iterator that yields `Ok(None)` forever after the underlying iterator\nyields `Ok(None)` once.",null,null],[3,"Iterator","","A normal (non-fallible) iterator which wraps a fallible iterator.",null,null],[3,"Map","","An iterator which applies a transform to the elements of the underlying\niterator.",null,null],[3,"MapErr","","An iterator which applies a transform to the errors of the underlying\niterator.",null,null],[3,"Peekable","","An iterator which can look at the next element without consuming it.",null,null],[3,"Rev","","An iterator which yields elements of the underlying iterator in reverse\norder.",null,null],[3,"Take","","An iterator which yields a limited number of elements from the underlying\niterator.",null,null],[3,"Zip","","An iterator that yields pairs of this iterator&#39;s and another iterator&#39;s\nvalues.",null,null],[5,"convert","","Converts an `Iterator&lt;Item = Result&lt;T, E&gt;&gt;` into a `FallibleIterator&lt;Item = T, Error = E&gt;`.",null,{"inputs":[{"name":"i"}],"output":{"name":"convert"}}],[8,"FallibleIterator","","An `Iterator`-like trait that allows for calculation of items to fail.",null,null],[16,"Item","","The type being iterated over.",0,null],[16,"Error","","The error type.",0,null],[10,"next","","Advances the iterator and returns the next value.",0,null],[11,"size_hint","","Returns bounds on the remaining length of the iterator.",0,null],[11,"all","","Determines if all elements of this iterator match a predicate.",0,null],[11,"and_then","","Returns an iterator which applies a fallible transform to the elements\nof the underlying iterator.",0,null],[11,"any","","Determines if any element of this iterator matches a predicate.",0,null],[11,"by_ref","","Borrow an iterator rather than consuming it.",0,null],[11,"chain","","Returns an iterator which yields the elements of this iterator followed\nby another.",0,null],[11,"cloned","","Returns an iterator which clones all of its elements.",0,null],[11,"count","","Consumes the iterator, returning the number of remaining items.",0,null],[11,"collect","","Transforms the iterator into a collection.",0,null],[11,"enumerate","","Returns an iterator which yields the current iteration count as well\nas the value.",0,null],[11,"filter","","Returns an iterator which uses a predicate to determine which values\nshould be yielded.",0,null],[11,"filter_map","","Returns an iterator which both filters and maps.",0,null],[11,"find","","Returns the first element of the iterator that matches a predicate.",0,null],[11,"fuse","","Returns an iterator which yields this iterator&#39;s elements and ends after\nthe first `Ok(None)`.",0,null],[11,"fold","","Applies a function over the elements of the iterator, producing a single\nfinal value.",0,null],[11,"iterator","","Returns a normal (non-fallible) iterator over `Result&lt;Item, Error&gt;`.",0,null],[11,"last","","Returns the last element of the iterator.",0,null],[11,"map","","Returns an iterator which applies a transform to the elements of the\nunderlying iterator.",0,null],[11,"map_err","","Returns an iterator which applies a transform to the errors of the\nunderlying iterator.",0,null],[11,"max","","Returns the maximal element of the iterator.",0,null],[11,"max_by_key","","Returns the element of the iterator which gives the maximum value from\nthe function.",0,null],[11,"min","","Returns the minimal element of the iterator.",0,null],[11,"min_by_key","","Returns the element of the iterator which gives the minimum value from\nthe function.",0,null],[11,"nth","","Returns the `n`th element of the iterator.",0,null],[11,"peekable","","Returns an iterator that can peek at the next element without consuming\nit.",0,null],[11,"position","","Returns the position of the first element of this iterator that matches\na predicate.",0,null],[11,"rev","","Returns an iterator that yields this iterator&#39;s items in the opposite\norder.",0,null],[11,"take","","Returns an iterator that yields only the first `n` values of this\niterator.",0,null],[11,"zip","","Returns an iterator that yields pairs of this iterator&#39;s and another\niterator&#39;s values.",0,null],[11,"cmp","","Lexicographically compares the elements of this iterator to that of\nanother.",0,null],[11,"partial_cmp","","Lexicographically compares the elements of this iterator to that of\nanother.",0,null],[11,"eq","","Determines if the elements of this iterator are equal to those of\nanother.",0,null],[11,"ne","","Determines if the elements of this iterator are not equal to those of\nanother.",0,null],[11,"lt","","Determines if the elements of this iterator are lexicographically less\nthan those of another.",0,null],[11,"le","","Determines if the elements of this iterator are lexicographically less\nthan or equal to those of another.",0,null],[11,"gt","","Determines if the elements of this iterator are lexicographically\ngreater than those of another.",0,null],[11,"ge","","Determines if the elements of this iterator are lexicographically\ngreater than or equal to those of another.",0,null],[8,"DoubleEndedFallibleIterator","","A fallible iterator able to yield elements from both ends.",null,null],[10,"next_back","","Advances the end of the iterator, returning the last value.",1,null],[8,"FromFallibleIterator","","Conversion from a fallible iterator.",null,null],[10,"from_fallible_iterator","","Creates a value from a fallible iterator.",2,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[8,"IntoFallibleIterator","","Conversion into a `FallibleIterator`.",null,null],[16,"Item","","The elements of the iterator.",3,null],[16,"Error","","The error value of the iterator.",3,null],[16,"IntoIter","","The iterator.",3,null],[10,"into_fallible_iterator","","Creates a fallible iterator from a value.",3,null],[11,"fmt","","",4,null],[11,"next","","",4,null],[11,"size_hint","","",4,null],[11,"fmt","","",5,null],[11,"next","","",5,null],[11,"size_hint","","",5,null],[11,"count","","",5,null],[11,"next_back","","",5,null],[11,"fmt","","",6,null],[11,"next","","",6,null],[11,"size_hint","","",6,null],[11,"count","","",6,null],[11,"next_back","","",6,null],[11,"fmt","","",7,null],[11,"next","","",7,null],[11,"size_hint","","",7,null],[11,"next_back","","",7,null],[11,"fmt","","",8,null],[11,"next","","",8,null],[11,"size_hint","","",8,null],[11,"count","","",8,null],[11,"fmt","","",9,null],[11,"next","","",9,null],[11,"size_hint","","",9,null],[11,"next_back","","",9,null],[11,"fmt","","",10,null],[11,"next","","",10,null],[11,"size_hint","","",10,null],[11,"next_back","","",10,null],[11,"fmt","","",11,null],[11,"next","","",11,null],[11,"size_hint","","",11,null],[11,"count","","",11,null],[11,"fmt","","",12,null],[11,"next","","",12,null],[11,"size_hint","","",12,null],[11,"next_back","","",12,null],[11,"fmt","","",13,null],[11,"next","","",13,null],[11,"size_hint","","",13,null],[11,"count","","",13,null],[11,"next_back","","",13,null],[11,"fmt","","",14,null],[11,"next","","",14,null],[11,"size_hint","","",14,null],[11,"count","","",14,null],[11,"next_back","","",14,null],[11,"fmt","","",15,null],[11,"peek","","Returns a reference to the next value without advancing the iterator.",15,null],[11,"next","","",15,null],[11,"size_hint","","",15,null],[11,"fmt","","",16,null],[11,"next","","",16,null],[11,"size_hint","","",16,null],[11,"count","","",16,null],[11,"next_back","","",16,null],[11,"fmt","","",17,null],[11,"next","","",17,null],[11,"size_hint","","",17,null],[11,"fmt","","",18,null],[11,"next","","",18,null],[11,"size_hint","","",18,null]],"paths":[[8,"FallibleIterator"],[8,"DoubleEndedFallibleIterator"],[8,"FromFallibleIterator"],[8,"IntoFallibleIterator"],[3,"AndThen"],[3,"Chain"],[3,"Cloned"],[3,"Convert"],[3,"Enumerate"],[3,"Filter"],[3,"FilterMap"],[3,"Fuse"],[3,"Iterator"],[3,"Map"],[3,"MapErr"],[3,"Peekable"],[3,"Rev"],[3,"Take"],[3,"Zip"]]};
searchIndex["gimli"] = {"doc":"A lazy, zero-copy parser for the DWARF debugging information format.","items":[[3,"DebugFrameOffset","gimli","An offset into the `.debug_frame` section.",null,null],[12,"0","","",0,null],[3,"EhFrameOffset","","An offset into the `.eh_frame` section.",null,null],[12,"0","","",1,null],[3,"DebugFrame","","`DebugFrame` contains the `.debug_frame` section&#39;s frame unwinding\ninformation required to unwind to and recover registers from older frames on\nthe stack. For example, this is useful for a debugger that wants to print\nlocals in a backtrace.",null,null],[3,"EhFrame","","`EhFrame` contains the frame unwinding information needed during exception\nhandling found in the `.eh_frame` section.",null,null],[3,"BaseAddresses","","Optional base addresses for the relative `DW_EH_PE_*` encoded pointers.",null,null],[12,"cfi","","The address of the current CFI unwind section (`.eh_frame` or\n`.debug_frame`) in memory.",2,null],[12,"text","","The address of the `.text` section in memory.",2,null],[12,"data","","The address of the `.data` section in memory.",2,null],[3,"CfiEntriesIter","","An iterator over CIE and FDE entries in a `.debug_frame` or `.eh_frame`\nsection.",null,null],[3,"Augmentation","","We support the z-style augmentation defined by `.eh_frame`.",null,null],[3,"CommonInformationEntry","","&gt; A Common Information Entry holds information that is shared among many\n&gt; Frame Description Entries. There is at least one CIE in every non-empty\n&gt; `.debug_frame` section.",null,null],[3,"PartialFrameDescriptionEntry","","A partially parsed `FrameDescriptionEntry`.",null,null],[3,"FrameDescriptionEntry","","A `FrameDescriptionEntry` is a set of CFA instructions for an address range.",null,null],[3,"UninitializedUnwindContext","","Common context needed when evaluating the call frame unwinding information.",null,null],[3,"InitializedUnwindContext","","An initialized unwinding context.",null,null],[3,"UnwindTable","","The `UnwindTable` iteratively evaluates a `FrameDescriptionEntry`&#39;s\n`CallFrameInstruction` program, yielding the each row one at a time.",null,null],[3,"RegisterRuleIter","","An unordered iterator for register rules.",null,null],[3,"UnwindTableRow","","A row in the virtual unwind table that describes how to find the values of\nthe registers in the *previous* frame for a range of PC addresses.",null,null],[3,"CallFrameInstructionIter","","A lazy iterator parsing call frame instructions.",null,null],[3,"DwCfa","","",null,null],[12,"0","","",3,null],[3,"DwChildren","","",null,null],[12,"0","","",4,null],[3,"DwTag","","",null,null],[12,"0","","",5,null],[3,"DwAt","","",null,null],[12,"0","","",6,null],[3,"DwForm","","",null,null],[12,"0","","",7,null],[3,"DwAte","","",null,null],[12,"0","","",8,null],[3,"DwDs","","",null,null],[12,"0","","",9,null],[3,"DwEnd","","",null,null],[12,"0","","",10,null],[3,"DwAccess","","",null,null],[12,"0","","",11,null],[3,"DwVis","","",null,null],[12,"0","","",12,null],[3,"DwVirtuality","","",null,null],[12,"0","","",13,null],[3,"DwLang","","",null,null],[12,"0","","",14,null],[3,"DwAddr","","",null,null],[12,"0","","",15,null],[3,"DwId","","",null,null],[12,"0","","",16,null],[3,"DwCc","","",null,null],[12,"0","","",17,null],[3,"DwInl","","",null,null],[12,"0","","",18,null],[3,"DwOrd","","",null,null],[12,"0","","",19,null],[3,"DwDsc","","",null,null],[12,"0","","",20,null],[3,"DwLns","","",null,null],[12,"0","","",21,null],[3,"DwLne","","",null,null],[12,"0","","",22,null],[3,"DwOp","","",null,null],[12,"0","","",23,null],[3,"DwEhPe","","",null,null],[12,"0","","",24,null],[3,"EndianBuf","","A `&amp;[u8]` slice with compile-time endianity metadata.",null,null],[12,"0","","",25,null],[12,"1","","",25,null],[3,"DebugMacinfoOffset","","An offset into the `.debug_macinfo` section.",null,null],[12,"0","","",26,null],[3,"DebugAbbrev","","The `DebugAbbrev` struct represents the abbreviations describing\n`DebuggingInformationEntry`s&#39; attribute names and forms found in the\n`.debug_abbrev` section.",null,null],[3,"DebugAbbrevOffset","","An offset into the `.debug_abbrev` section.",null,null],[12,"0","","",27,null],[3,"Abbreviations","","A set of type abbreviations.",null,null],[3,"Abbreviation","","An abbreviation describes the shape of a `DebuggingInformationEntry`&#39;s type:\nits code, tag type, whether it has children, and its set of attributes.",null,null],[3,"AttributeSpecification","","The description of an attribute in an abbreviated type. It is a pair of name\nand form.",null,null],[3,"ArangeEntry","","A single parsed arange.",null,null],[3,"DebugLineOffset","","An offset into the `.debug_line` section.",null,null],[12,"0","","",28,null],[3,"DebugLine","","The `DebugLine` struct contains the source location to instruction mapping\nfound in the `.debug_line` section.",null,null],[3,"StateMachine","","Executes a `LineNumberProgram` to recreate the matrix mapping to and from\ninstructions to source locations.",null,null],[3,"OpcodesIter","","An iterator yielding parsed opcodes.",null,null],[3,"LineNumberRow","","A row in the line number program&#39;s resulting matrix.",null,null],[3,"LineNumberSequence","","A sequence within a line number program.  A sequence, as defined in section\n6.2.5 of the standard, is a linear subset of a line number program within\nwhich addresses are monotonically increasing.",null,null],[12,"start","","The first address that is covered by this sequence within the line number\nprogram.",29,null],[12,"end","","The first address that is *not* covered by this sequence within the line\nnumber program.",29,null],[3,"LineNumberProgramHeader","","A header for a line number program in the `.debug_line` section, as defined\nin section 6.2.4 of the standard.",null,null],[3,"IncompleteLineNumberProgram","","A line number program that has not been run to completion.",null,null],[3,"CompleteLineNumberProgram","","A line number program that has previously been run to completion.",null,null],[3,"FileEntry","","An entry in the `LineNumberProgramHeader`&#39;s `file_names` set.",null,null],[3,"DebugLoc","","The `DebugLoc` struct represents the DWARF strings\nfound in the `.debug_loc` section.",null,null],[3,"DebugLocOffset","","An offset into the `.debug_loc` section.",null,null],[12,"0","","",30,null],[3,"LocationListIter","","An iterator over a location list.",null,null],[3,"RawLocationListIter","","A raw iterator over a location list.",null,null],[3,"LocationListEntry","","A location list entry from the `.debug_loc` section.",null,null],[12,"range","","The address range that this location is valid for.",31,null],[12,"data","","The data containing a single location description.",31,null],[3,"Piece","","The description of a single piece of the result of a DWARF\nexpression.",null,null],[12,"size_in_bits","","If given, the size of the piece in bits.  If `None`, then the\npiece takes its size from the enclosed location.",32,null],[12,"bit_offset","","If given, the bit offset of the piece.  If `None`, then the\npiece starts at the next byte boundary.",32,null],[12,"location","","Where this piece is to be found.",32,null],[3,"Evaluation","","A DWARF expression evaluator.",null,null],[3,"PubNamesEntry","","A single parsed pubname.",null,null],[3,"PubTypesEntry","","A single parsed pubtype.",null,null],[3,"DebugRanges","","The `DebugRanges` struct represents the DWARF strings\nfound in the `.debug_ranges` section.",null,null],[3,"DebugRangesOffset","","An offset into the `.debug_ranges` section.",null,null],[12,"0","","",33,null],[3,"RangesIter","","An iterator over an address range list.",null,null],[3,"RawRangesIter","","A raw iterator over an address range list.",null,null],[3,"Range","","An address range from the `.debug_ranges` section.",null,null],[12,"begin","","The beginning address of the range.",34,null],[12,"end","","The first address past the end of the range.",34,null],[3,"DebugStrOffset","","An offset into the `.debug_str` section.",null,null],[12,"0","","",35,null],[3,"DebugStr","","The `DebugStr` struct represents the DWARF strings\nfound in the `.debug_str` section.",null,null],[3,"DebugInfo","","The `DebugInfo` struct represents the DWARF debugging information found in\nthe `.debug_info` section.",null,null],[3,"DebugInfoOffset","","An offset into the `.debug_info` section.",null,null],[12,"0","","",36,null],[3,"CompilationUnitHeadersIter","","An iterator over the compilation- and partial-units of a section.",null,null],[3,"CompilationUnitHeader","","The header of a compilation unit&#39;s debugging information.",null,null],[3,"UnitOffset","","An offset into the current compilation or type unit.",null,null],[12,"0","","",37,null],[3,"DebugTypes","","The `DebugTypes` struct represents the DWARF type information\nfound in the `.debug_types` section.",null,null],[3,"DebugTypesOffset","","An offset into the `.debug_types` section.",null,null],[12,"0","","",38,null],[3,"DebugTypeSignature","","A type signature as used in the `.debug_types` section.",null,null],[12,"0","","",39,null],[3,"TypeUnitHeadersIter","","An iterator over the type-units of this `.debug_types` section.",null,null],[3,"TypeUnitHeader","","The header of a type unit&#39;s debugging information.",null,null],[3,"EntriesCursor","","A cursor into the Debugging Information Entries tree for a compilation unit.",null,null],[3,"EntriesTree","","The state information for a tree view of the Debugging Information Entries.",null,null],[3,"EntriesTreeIter","","An iterator that allows recursive traversal of the Debugging\nInformation Entry tree.",null,null],[3,"DebuggingInformationEntry","","A Debugging Information Entry (DIE).",null,null],[3,"AttrsIter","","An iterator over a particular entry&#39;s attributes.",null,null],[3,"Attribute","","An attribute in a `DebuggingInformationEntry`, consisting of a name and\nassociated value.",null,null],[4,"CieOrFde","","Either a `CommonInformationEntry` (CIE) or a `FrameDescriptionEntry` (FDE).",null,null],[13,"Cie","","This CFI entry is a `CommonInformationEntry`.",40,null],[13,"Fde","","This CFI entry is a `FrameDescriptionEntry`, however fully parsing it\nrequires parsing its CIE first, so it is left in a partially parsed\nstate.",40,null],[4,"CfaRule","","The canonical frame address (CFA) recovery rules.",null,null],[13,"RegisterAndOffset","","The CFA is given offset from the given register&#39;s value.",41,null],[12,"register","gimli::CfaRule","The register containing the base value.",41,null],[12,"offset","","The offset from the register&#39;s base value.",41,null],[13,"Expression","gimli","The CFA is obtained by evaluating this `EndianBuf` as a DWARF expression\nprogram.",41,null],[4,"RegisterRule","","An entry in the abstract CFI table that describes how to find the value of a\nregister.",null,null],[13,"Undefined","","&gt; A register that has this rule has no recoverable value in the previous\n&gt; frame. (By convention, it is not preserved by a callee.)",42,null],[13,"SameValue","","&gt; This register has not been modified from the previous frame. (By\n&gt; convention, it is preserved by the callee, but the callee has not\n&gt; modified it.)",42,null],[13,"Offset","","&quot;The previous value of this register is saved at the address CFA+N where\nCFA is the current CFA value and N is a signed offset.&quot;",42,null],[13,"ValOffset","","&quot;The previous value of this register is the value CFA+N where CFA is the\ncurrent CFA value and N is a signed offset.&quot;",42,null],[13,"Register","","&quot;The previous value of this register is stored in another register\nnumbered R.&quot;",42,null],[13,"Expression","","&quot;The previous value of this register is located at the address produced\nby executing the DWARF expression.&quot;",42,null],[13,"ValExpression","","&quot;The previous value of this register is the value produced by executing\nthe DWARF expression.&quot;",42,null],[13,"Architectural","","&quot;The rule is defined externally to this specification by the augmenter.&quot;",42,null],[4,"CallFrameInstruction","","A parsed call frame instruction.",null,null],[13,"SetLoc","","&gt; 1. DW_CFA_set_loc\n&gt;\n&gt; The DW_CFA_set_loc instruction takes a single operand that represents\n&gt; a target address. The required action is to create a new table row\n&gt; using the specified address as the location. All other values in the\n&gt; new row are initially identical to the current row. The new location\n&gt; value is always greater than the current one. If the segment_size\n&gt; field of this FDE&#39;s CIE is non- zero, the initial location is preceded\n&gt; by a segment selector of the given length.",43,null],[12,"address","gimli::CallFrameInstruction","The target address.",43,null],[13,"AdvanceLoc","gimli","The `AdvanceLoc` instruction is used for all of `DW_CFA_advance_loc` and\n`DW_CFA_advance_loc{1,2,4}`.",43,null],[12,"delta","gimli::CallFrameInstruction","The delta to be added to the current address.",43,null],[13,"DefCfa","gimli","&gt; 1. DW_CFA_def_cfa\n&gt;\n&gt; The DW_CFA_def_cfa instruction takes two unsigned LEB128 operands\n&gt; representing a register number and a (non-factored) offset. The\n&gt; required action is to define the current CFA rule to use the provided\n&gt; register and offset.",43,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",43,null],[12,"offset","","The non-factored offset.",43,null],[13,"DefCfaSf","gimli","&gt; 2. DW_CFA_def_cfa_sf\n&gt;\n&gt; The DW_CFA_def_cfa_sf instruction takes two operands: an unsigned\n&gt; LEB128 value representing a register number and a signed LEB128\n&gt; factored offset. This instruction is identical to DW_CFA_def_cfa\n&gt; except that the second operand is signed and factored. The resulting\n&gt; offset is factored_offset * data_alignment_factor.",43,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",43,null],[12,"factored_offset","","The factored offset.",43,null],[13,"DefCfaRegister","gimli","&gt; 3. DW_CFA_def_cfa_register\n&gt;\n&gt; The DW_CFA_def_cfa_register instruction takes a single unsigned LEB128\n&gt; operand representing a register number. The required action is to\n&gt; define the current CFA rule to use the provided register (but to keep\n&gt; the old offset). This operation is valid only if the current CFA rule\n&gt; is defined to use a register and offset.",43,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",43,null],[13,"DefCfaOffset","gimli","&gt; 4. DW_CFA_def_cfa_offset\n&gt;\n&gt; The DW_CFA_def_cfa_offset instruction takes a single unsigned LEB128\n&gt; operand representing a (non-factored) offset. The required action is\n&gt; to define the current CFA rule to use the provided offset (but to keep\n&gt; the old register). This operation is valid only if the current CFA\n&gt; rule is defined to use a register and offset.",43,null],[12,"offset","gimli::CallFrameInstruction","The non-factored offset.",43,null],[13,"DefCfaOffsetSf","gimli","&gt; 5. DW_CFA_def_cfa_offset_sf\n&gt;\n&gt; The DW_CFA_def_cfa_offset_sf instruction takes a signed LEB128 operand\n&gt; representing a factored offset. This instruction is identical to\n&gt; DW_CFA_def_cfa_offset except that the operand is signed and\n&gt; factored. The resulting offset is factored_offset *\n&gt; data_alignment_factor. This operation is valid only if the current CFA\n&gt; rule is defined to use a register and offset.",43,null],[12,"factored_offset","gimli::CallFrameInstruction","The factored offset.",43,null],[13,"DefCfaExpression","gimli","&gt; 6. DW_CFA_def_cfa_expression\n&gt;\n&gt; The DW_CFA_def_cfa_expression instruction takes a single operand\n&gt; encoded as a DW_FORM_exprloc value representing a DWARF\n&gt; expression. The required action is to establish that expression as the\n&gt; means by which the current CFA is computed.",43,null],[12,"expression","gimli::CallFrameInstruction","The DWARF expression.",43,null],[13,"Undefined","gimli","&gt; 1. DW_CFA_undefined\n&gt;\n&gt; The DW_CFA_undefined instruction takes a single unsigned LEB128\n&gt; operand that represents a register number. The required action is to\n&gt; set the rule for the specified register to “undefined.”",43,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",43,null],[13,"SameValue","gimli","&gt; 2. DW_CFA_same_value\n&gt;\n&gt; The DW_CFA_same_value instruction takes a single unsigned LEB128\n&gt; operand that represents a register number. The required action is to\n&gt; set the rule for the specified register to “same value.”",43,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",43,null],[13,"Offset","gimli","The `Offset` instruction represents both `DW_CFA_offset` and\n`DW_CFA_offset_extended`.",43,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",43,null],[12,"factored_offset","","The factored offset.",43,null],[13,"OffsetExtendedSf","gimli","&gt; 5. DW_CFA_offset_extended_sf\n&gt;\n&gt; The DW_CFA_offset_extended_sf instruction takes two operands: an\n&gt; unsigned LEB128 value representing a register number and a signed\n&gt; LEB128 factored offset. This instruction is identical to\n&gt; DW_CFA_offset_extended except that the second operand is signed and\n&gt; factored. The resulting offset is factored_offset *\n&gt; data_alignment_factor.",43,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",43,null],[12,"factored_offset","","The factored offset.",43,null],[13,"ValOffset","gimli","&gt; 6. DW_CFA_val_offset\n&gt;\n&gt; The DW_CFA_val_offset instruction takes two unsigned LEB128 operands\n&gt; representing a register number and a factored offset. The required\n&gt; action is to change the rule for the register indicated by the\n&gt; register number to be a val_offset(N) rule where the value of N is\n&gt; factored_offset * data_alignment_factor.",43,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",43,null],[12,"factored_offset","","The factored offset.",43,null],[13,"ValOffsetSf","gimli","&gt; 7. DW_CFA_val_offset_sf\n&gt;\n&gt; The DW_CFA_val_offset_sf instruction takes two operands: an unsigned\n&gt; LEB128 value representing a register number and a signed LEB128\n&gt; factored offset. This instruction is identical to DW_CFA_val_offset\n&gt; except that the second operand is signed and factored. The resulting\n&gt; offset is factored_offset * data_alignment_factor.",43,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",43,null],[12,"factored_offset","","The factored offset.",43,null],[13,"Register","gimli","&gt; 8. DW_CFA_register\n&gt;\n&gt; The DW_CFA_register instruction takes two unsigned LEB128 operands\n&gt; representing register numbers. The required action is to set the rule\n&gt; for the first register to be register(R) where R is the second\n&gt; register.",43,null],[12,"dest_register","gimli::CallFrameInstruction","The number of the register whose rule is being changed.",43,null],[12,"src_register","","The number of the register where the other register&#39;s value can be\nfound.",43,null],[13,"Expression","gimli","&gt; 9. DW_CFA_expression\n&gt;\n&gt; The DW_CFA_expression instruction takes two operands: an unsigned\n&gt; LEB128 value representing a register number, and a DW_FORM_block value\n&gt; representing a DWARF expression. The required action is to change the\n&gt; rule for the register indicated by the register number to be an\n&gt; expression(E) rule where E is the DWARF expression. That is, the DWARF\n&gt; expression computes the address. The value of the CFA is pushed on the\n&gt; DWARF evaluation stack prior to execution of the DWARF expression.",43,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",43,null],[12,"expression","","The DWARF expression.",43,null],[13,"ValExpression","gimli","&gt; 10. DW_CFA_val_expression\n&gt;\n&gt; The DW_CFA_val_expression instruction takes two operands: an unsigned\n&gt; LEB128 value representing a register number, and a DW_FORM_block value\n&gt; representing a DWARF expression. The required action is to change the\n&gt; rule for the register indicated by the register number to be a\n&gt; val_expression(E) rule where E is the DWARF expression. That is, the\n&gt; DWARF expression computes the value of the given register. The value\n&gt; of the CFA is pushed on the DWARF evaluation stack prior to execution\n&gt; of the DWARF expression.",43,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",43,null],[12,"expression","","The DWARF expression.",43,null],[13,"Restore","gimli","The `Restore` instruction represents both `DW_CFA_restore` and\n`DW_CFA_restore_extended`.",43,null],[12,"register","gimli::CallFrameInstruction","The register to be reset.",43,null],[13,"RememberState","gimli","&gt; 1. DW_CFA_remember_state\n&gt;\n&gt; The DW_CFA_remember_state instruction takes no operands. The required\n&gt; action is to push the set of rules for every register onto an implicit\n&gt; stack.",43,null],[13,"RestoreState","","&gt; 2. DW_CFA_restore_state\n&gt;\n&gt; The DW_CFA_restore_state instruction takes no operands. The required\n&gt; action is to pop the set of rules off the implicit stack and place\n&gt; them in the current row.",43,null],[13,"Nop","","&gt; 1. DW_CFA_nop\n&gt;\n&gt; The DW_CFA_nop instruction has no operands and no required actions. It\n&gt; is used as padding to make a CIE or FDE an appropriate size.",43,null],[4,"LittleEndian","","Little endian byte order.",null,null],[4,"BigEndian","","Big endian byte order.",null,null],[4,"Error","","An error that occurred when parsing.",null,null],[13,"CfiRelativePointerButCfiBaseIsUndefined","","Found a CFI relative pointer, but the CFI base is undefined.",44,null],[13,"TextRelativePointerButTextBaseIsUndefined","","Found a `.text` relative pointer, but the `.text` base is undefined.",44,null],[13,"DataRelativePointerButDataBaseIsUndefined","","Found a `.data` relative pointer, but the `.data` base is undefined.",44,null],[13,"FuncRelativePointerInBadContext","","Found a function relative pointer in a context that does not have a\nfunction base.",44,null],[13,"BadUnsignedLeb128","","An error parsing an unsigned LEB128 value.",44,null],[13,"BadSignedLeb128","","An error parsing a signed LEB128 value.",44,null],[13,"AbbreviationTagZero","","An abbreviation declared that its tag is zero, but zero is reserved for\nnull records.",44,null],[13,"AttributeFormZero","","An attribute specification declared that its form is zero, but zero is\nreserved for null records.",44,null],[13,"BadHasChildren","","The abbreviation&#39;s has-children byte was not one of\n`DW_CHILDREN_{yes,no}`.",44,null],[13,"BadLength","","The specified length is impossible.",44,null],[13,"UnknownForm","","Found an unknown `DW_FORM_*` type.",44,null],[13,"ExpectedZero","","Expected a zero, found something else.",44,null],[13,"DuplicateAbbreviationCode","","Found an abbreviation code that has already been used.",44,null],[13,"DuplicateArange","","Found a duplicate arange.",44,null],[13,"UnknownReservedLength","","Found an unknown reserved length value.",44,null],[13,"UnknownVersion","","Found an unknown DWARF version.",44,null],[13,"UnitHeaderLengthTooShort","","The unit header&#39;s claimed length is too short to even hold the header\nitself.",44,null],[13,"UnknownAbbreviation","","Found a record with an unknown abbreviation code.",44,null],[13,"UnexpectedEof","","Hit the end of input before it was expected.",44,null],[13,"UnexpectedNull","","Read a null entry before it was expected.",44,null],[13,"UnknownStandardOpcode","","Found an unknown standard opcode.",44,null],[13,"UnknownExtendedOpcode","","Found an unknown extended opcode.",44,null],[13,"UnsupportedAddressSize","","The specified address size is not supported.",44,null],[13,"UnsupportedFieldSize","","The specified field size is not supported.",44,null],[13,"MinimumInstructionLengthZero","","The minimum instruction length must not be zero.",44,null],[13,"MaximumOperationsPerInstructionZero","","The maximum operations per instruction must not be zero.",44,null],[13,"LineRangeZero","","The line range must not be zero.",44,null],[13,"OpcodeBaseZero","","The opcode base must not be zero.",44,null],[13,"BadUtf8","","Found an invalid UTF-8 string.",44,null],[13,"NotCieId","","Expected to find the CIE ID, but found something else.",44,null],[13,"NotCiePointer","","Expected to find a pointer to a CIE, but found the CIE ID instead.",44,null],[13,"BadBranchTarget","","Invalid branch target for a DW_OP_bra or DW_OP_skip.",44,null],[13,"InvalidPushObjectAddress","","DW_OP_push_object_address used but no address passed in.",44,null],[13,"NotEnoughStackItems","","Not enough items on the stack when evaluating an expression.",44,null],[13,"TooManyIterations","","Too many iterations to compute the expression.",44,null],[13,"InvalidExpression","","An unrecognized operation was found while parsing a DWARF\nexpression.",44,null],[13,"InvalidPiece","","The expression had a piece followed by an expression\nterminator without a piece.",44,null],[13,"InvalidExpressionTerminator","","An expression-terminating operation was followed by something\nother than the end of the expression or a piece operation.",44,null],[13,"DivisionByZero","","Division or modulus by zero when evaluating an expression.",44,null],[13,"UnknownCallFrameInstruction","","An unknown DW_CFA_* instruction.",44,null],[13,"InvalidAddressRange","","The end of an address range was before the beginning.",44,null],[13,"InvalidLocationAddressRange","","The end offset of a loc list entry was before the beginning.",44,null],[13,"CfiInstructionInInvalidContext","","Encountered a call frame instruction in a context in which it is not\nvalid.",44,null],[13,"PopWithEmptyStack","","When evaluating call frame instructions, found a `DW_CFA_restore_state`\nstack pop instruction, but the stack was empty, and had nothing to pop.",44,null],[13,"NoUnwindInfoForAddress","","Do not have unwind info for the given address.",44,null],[13,"UnsupportedOffset","","An offset value was larger than the maximum supported value.",44,null],[13,"UnknownPointerEncoding","","The given pointer encoding is either unknown or invalid.",44,null],[13,"NoEntryAtGivenOffset","","Did not find an entry at the given offset.",44,null],[13,"OffsetOutOfBounds","","The given offset is out of bounds.",44,null],[13,"UnknownAugmentation","","Found an unknown CFI augmentation.",44,null],[13,"UnsupportedPointerEncoding","","We do not support the given pointer encoding yet.",44,null],[13,"CannotFitInU8","","We tried to convert some number into a `u8`, but it was too large.",44,null],[13,"TooManyRegisterRules","","The CFI program defined more register rules than we have storage for.",44,null],[13,"CfiStackFull","","Attempted to push onto the CFI stack, but it was already at full\ncapacity.",44,null],[4,"Format","","Whether the format of a compilation unit is 32- or 64-bit.",null,null],[13,"Dwarf64","","64-bit DWARF",45,null],[13,"Dwarf32","","32-bit DWARF",45,null],[4,"Opcode","","A parsed line number program opcode.",null,null],[13,"Special","","&gt; ### 6.2.5.1 Special Opcodes\n&gt;\n&gt; Each ubyte special opcode has the following effect on the state machine:\n&gt;\n&gt;   1. Add a signed integer to the line register.\n&gt;\n&gt;   2. Modify the operation pointer by incrementing the address and\n&gt;   op_index registers as described below.\n&gt;\n&gt;   3. Append a row to the matrix using the current values of the state\n&gt;   machine registers.\n&gt;\n&gt;   4. Set the basic_block register to “false.”\n&gt;\n&gt;   5. Set the prologue_end register to “false.”\n&gt;\n&gt;   6. Set the epilogue_begin register to “false.”\n&gt;\n&gt;   7. Set the discriminator register to 0.\n&gt;\n&gt; All of the special opcodes do those same seven things; they differ from\n&gt; one another only in what values they add to the line, address and\n&gt; op_index registers.",46,null],[13,"Copy","","&quot;[`Opcode::Copy`] appends a row to the matrix using the current values of the state\nmachine registers. Then it sets the discriminator register to 0, and\nsets the basic_block, prologue_end and epilogue_begin registers to\n“false.”&quot;",46,null],[13,"AdvancePc","","&quot;The DW_LNS_advance_pc opcode takes a single unsigned LEB128 operand as\nthe operation advance and modifies the address and op_index registers\n[the same as `Opcode::Special`]&quot;",46,null],[13,"AdvanceLine","","&quot;The DW_LNS_advance_line opcode takes a single signed LEB128 operand and\nadds that value to the line register of the state machine.&quot;",46,null],[13,"SetFile","","&quot;The DW_LNS_set_file opcode takes a single unsigned LEB128 operand and\nstores it in the file register of the state machine.&quot;",46,null],[13,"SetColumn","","&quot;The DW_LNS_set_column opcode takes a single unsigned LEB128 operand and\nstores it in the column register of the state machine.&quot;",46,null],[13,"NegateStatement","","&quot;The DW_LNS_negate_stmt opcode takes no operands. It sets the is_stmt\nregister of the state machine to the logical negation of its current\nvalue.&quot;",46,null],[13,"SetBasicBlock","","&quot;The DW_LNS_set_basic_block opcode takes no operands. It sets the\nbasic_block register of the state machine to “true.”&quot;",46,null],[13,"ConstAddPc","","&gt; The DW_LNS_const_add_pc opcode takes no operands. It advances the\n&gt; address and op_index registers by the increments corresponding to\n&gt; special opcode 255.\n&gt;\n&gt; When the line number program needs to advance the address by a small\n&gt; amount, it can use a single special opcode, which occupies a single\n&gt; byte. When it needs to advance the address by up to twice the range of\n&gt; the last special opcode, it can use DW_LNS_const_add_pc followed by a\n&gt; special opcode, for a total of two bytes. Only if it needs to advance\n&gt; the address by more than twice that range will it need to use both\n&gt; DW_LNS_advance_pc and a special opcode, requiring three or more bytes.",46,null],[13,"FixedAddPc","","&gt; The DW_LNS_fixed_advance_pc opcode takes a single uhalf (unencoded)\n&gt; operand and adds it to the address register of the state machine and\n&gt; sets the op_index register to 0. This is the only standard opcode whose\n&gt; operand is not a variable length number. It also does not multiply the\n&gt; operand by the minimum_instruction_length field of the header.",46,null],[13,"SetPrologueEnd","","&quot;[`Opcode::SetPrologueEnd`] sets the prologue_end register to “true”.&quot;",46,null],[13,"SetEpilogueBegin","","&quot;[`Opcode::SetEpilogueBegin`] sets the epilogue_begin register to\n“true”.&quot;",46,null],[13,"SetIsa","","&quot;The DW_LNS_set_isa opcode takes a single unsigned LEB128 operand and\nstores that value in the isa register of the state machine.&quot;",46,null],[13,"UnknownStandard0","","An unknown standard opcode with zero operands.",46,null],[13,"UnknownStandard1","","An unknown standard opcode with one operand.",46,null],[13,"UnknownStandardN","","An unknown standard opcode with multiple operands.",46,null],[13,"EndSequence","","&gt; [`Opcode::EndSequence`] sets the end_sequence register of the state\n&gt; machine to “true” and appends a row to the matrix using the current\n&gt; values of the state-machine registers. Then it resets the registers to\n&gt; the initial values specified above (see Section 6.2.2). Every line\n&gt; number program sequence must end with a DW_LNE_end_sequence instruction\n&gt; which creates a row whose address is that of the byte after the last\n&gt; target machine instruction of the sequence.",46,null],[13,"SetAddress","","&gt; The DW_LNE_set_address opcode takes a single relocatable address as an\n&gt; operand. The size of the operand is the size of an address on the target\n&gt; machine. It sets the address register to the value given by the\n&gt; relocatable address and sets the op_index register to 0.\n&gt;\n&gt; All of the other line number program opcodes that affect the address\n&gt; register add a delta to it. This instruction stores a relocatable value\n&gt; into it instead.",46,null],[13,"DefineFile","","Defines a new source file in the line number program and appends it to\nthe line number program header&#39;s list of source files.",46,null],[13,"SetDiscriminator","","&quot;The DW_LNE_set_discriminator opcode takes a single parameter, an\nunsigned LEB128 integer. It sets the discriminator register to the new\nvalue.&quot;",46,null],[13,"UnknownExtended","","An unknown extended opcode and the slice of its unparsed operands.",46,null],[4,"ColumnType","","The type of column that a row is referring to.",null,null],[13,"LeftEdge","","The `LeftEdge` means that the statement begins at the start of the new\nline.",47,null],[13,"Column","","A column number, whose range begins at 1.",47,null],[4,"DieReference","","A reference to a DIE, either relative to the current CU or\nrelative to the section.",null,null],[13,"UnitRef","","A CU-relative reference.",48,null],[13,"DebugInfoRef","","A section-relative reference.",48,null],[4,"Operation","","A single decoded DWARF expression operation.",null,null],[13,"Deref","","A dereference operation.",49,null],[12,"size","gimli::Operation","The size of the data to dereference.",49,null],[12,"space","","True if the dereference operation takes an address space\nargument; false otherwise.",49,null],[13,"Drop","gimli","Drop an item from the stack.",49,null],[13,"Pick","","Pick an item from the stack and push it on top of the stack.\nThis operation handles `DW_OP_pick`, `DW_OP_dup`, and\n`DW_OP_over`.",49,null],[12,"index","gimli::Operation","The index, from the top of the stack, of the item to copy.",49,null],[13,"Swap","gimli","Swap the top two stack items.",49,null],[13,"Rot","","Rotate the top three stack items.",49,null],[13,"Abs","","Take the absolute value of the top of the stack.",49,null],[13,"And","","Bitwise `and` of the top two values on the stack.",49,null],[13,"Div","","Divide the top two values on the stack.",49,null],[13,"Minus","","Subtract the top two values on the stack.",49,null],[13,"Mod","","Modulus of the top two values on the stack.",49,null],[13,"Mul","","Multiply the top two values on the stack.",49,null],[13,"Neg","","Negate the top of the stack.",49,null],[13,"Not","","Bitwise `not` of the top of the stack.",49,null],[13,"Or","","Bitwise `or` of the top two values on the stack.",49,null],[13,"Plus","","Add the top two values on the stack.",49,null],[13,"PlusConstant","","Add a constant to the topmost value on the stack.",49,null],[12,"value","gimli::Operation","The value to add.",49,null],[13,"Shl","gimli","Logical left shift of the 2nd value on the stack by the number\nof bits given by the topmost value on the stack.",49,null],[13,"Shr","","Right shift of the 2nd value on the stack by the number of\nbits given by the topmost value on the stack.",49,null],[13,"Shra","","Arithmetic left shift of the 2nd value on the stack by the\nnumber of bits given by the topmost value on the stack.",49,null],[13,"Xor","","Bitwise `xor` of the top two values on the stack.",49,null],[13,"Bra","","Branch to the target location if the top of stack is nonzero.",49,null],[12,"target","gimli::Operation","The target bytecode.",49,null],[13,"Eq","gimli","Compare the top two stack values for equality.",49,null],[13,"Ge","","Compare the top two stack values using `&gt;=`.",49,null],[13,"Gt","","Compare the top two stack values using `&gt;`.",49,null],[13,"Le","","Compare the top two stack values using `&lt;=`.",49,null],[13,"Lt","","Compare the top two stack values using `&lt;`.",49,null],[13,"Ne","","Compare the top two stack values using `!=`.",49,null],[13,"Skip","","Unconditional branch to the target location.",49,null],[12,"target","gimli::Operation","The target bytecode.",49,null],[13,"Literal","gimli","Push a constant value on the stack.  This handles multiple\nDWARF opcodes, including `DW_OP_addr`.",49,null],[12,"value","gimli::Operation","The value to push.",49,null],[13,"Register","gimli","Indicate that this piece&#39;s location is in the given register.",49,null],[12,"register","gimli::Operation","The register number.",49,null],[13,"RegisterOffset","gimli","Find the value of the given register, add the offset, and then\npush the resulting sum on the stack.",49,null],[12,"register","gimli::Operation","The register number.",49,null],[12,"offset","","The offset to add.",49,null],[13,"FrameOffset","gimli","Compute the frame base (using `DW_AT_frame_base`), add the\ngiven offset, and then push the resulting sum on the stack.",49,null],[12,"offset","gimli::Operation","The offset to add.",49,null],[13,"Nop","gimli","No operation.",49,null],[13,"PushObjectAddress","","Push the object address on the stack.",49,null],[13,"Call","","Evaluate a DWARF expression as a subroutine.  The expression\ncomes from the `DW_AT_location` attribute of the indicated\nDIE.",49,null],[12,"offset","gimli::Operation","The DIE to use.",49,null],[13,"TLS","gimli","Compute the address of a thread-local variable and push it on\nthe stack.",49,null],[13,"CallFrameCFA","","Compute the call frame CFA and push it on the stack.",49,null],[13,"Piece","","Terminate a piece.",49,null],[12,"size_in_bits","gimli::Operation","The size of this piece in bits.",49,null],[12,"bit_offset","","The bit offset of this piece.  If `None`, then this piece\nwas specified using `DW_OP_piece` and should start at the\nnext byte boundary.",49,null],[13,"ImplicitValue","gimli","Represents `DW_OP_implicit_value`.",49,null],[12,"data","gimli::Operation","The implicit value to use.",49,null],[13,"StackValue","gimli","Represents `DW_OP_stack_value`.",49,null],[13,"ImplicitPointer","","Represents `DW_OP_implicit_pointer`. The object is a pointer to\na value which has no actual location, such as an implicit value or\na stack value.",49,null],[12,"value","gimli::Operation","The `.debug_info` offset of the value that this is an implicit pointer into.",49,null],[12,"byte_offset","","The byte offset into the value that the implicit pointer points to.",49,null],[13,"EntryValue","gimli","Represents `DW_OP_entry_value`. Evaluate an expression at the entry to\nthe current subprogram, and push it on the stack.",49,null],[12,"expression","gimli::Operation","The expression to be evaluated.",49,null],[4,"Location","gimli","A single location of a piece of the result of a DWARF expression.",null,null],[13,"Empty","","The piece is empty.  Ordinarily this means the piece has been\noptimized away.",50,null],[13,"Register","","The piece is found in a register.",50,null],[12,"register","gimli::Location","The register number.",50,null],[13,"Address","gimli","The piece is found in memory.",50,null],[12,"address","gimli::Location","The address.",50,null],[13,"Scalar","gimli","The piece is a scalar value.",50,null],[12,"value","gimli::Location","The value.",50,null],[13,"Bytes","gimli","The piece is represented by some constant bytes.",50,null],[12,"value","gimli::Location","The value.",50,null],[13,"ImplicitPointer","gimli","The piece is a pointer to a value which has no actual location.",50,null],[12,"value","gimli::Location","The `.debug_info` offset of the value that this is an implicit pointer into.",50,null],[12,"byte_offset","","The byte offset into the value that the implicit pointer points to.",50,null],[4,"AttributeValue","gimli","The value of an attribute in a `DebuggingInformationEntry`.",null,null],[13,"Addr","","&quot;Refers to some location in the address space of the described program.&quot;",51,null],[13,"Block","","A slice of an arbitrary number of bytes.",51,null],[13,"Data","","A one, two, four, or eight byte constant data value. How to interpret\nthe bytes depends on context.",51,null],[13,"Sdata","","A signed integer constant.",51,null],[13,"Udata","","An unsigned integer constant.",51,null],[13,"Exprloc","","&quot;The information bytes contain a DWARF expression (see Section 2.5) or\nlocation description (see Section 2.6).&quot;",51,null],[13,"Flag","","A boolean typically used to describe the presence or absence of another\nattribute.",51,null],[13,"SecOffset","","An offset into another section. Which section this is an offset into\ndepends on context.",51,null],[13,"UnitRef","","An offset into the current compilation unit.",51,null],[13,"DebugInfoRef","","An offset into the current `.debug_info` section, but possibly a\ndifferent compilation unit from the current one.",51,null],[13,"DebugLineRef","","An offset into the `.debug_line` section.",51,null],[13,"DebugLocRef","","An offset into the `.debug_loc` section.",51,null],[13,"DebugMacinfoRef","","An offset into the `.debug_macinfo` section.",51,null],[13,"DebugRangesRef","","An offset into the `.debug_ranges` section.",51,null],[13,"DebugTypesRef","","A type signature.",51,null],[13,"DebugStrRef","","An offset into the `.debug_str` section.",51,null],[13,"String","","A null terminated C string, including the final null byte. Not\nguaranteed to be UTF-8 or anything like that.",51,null],[13,"Encoding","","The value of a `DW_AT_encoding` attribute.",51,null],[13,"DecimalSign","","The value of a `DW_AT_decimal_sign` attribute.",51,null],[13,"Endianity","","The value of a `DW_AT_endianity` attribute.",51,null],[13,"Accessibility","","The value of a `DW_AT_accessibility` attribute.",51,null],[13,"Visibility","","The value of a `DW_AT_visibility` attribute.",51,null],[13,"Virtuality","","The value of a `DW_AT_virtuality` attribute.",51,null],[13,"Language","","The value of a `DW_AT_language` attribute.",51,null],[13,"AddressClass","","The value of a `DW_AT_address_class` attribute.",51,null],[13,"IdentifierCase","","The value of a `DW_AT_identifier_case` attribute.",51,null],[13,"CallingConvention","","The value of a `DW_AT_calling_convention` attribute.",51,null],[13,"Inline","","The value of a `DW_AT_inline` attribute.",51,null],[13,"Ordering","","The value of a `DW_AT_ordering` attribute.",51,null],[13,"FileIndex","","An index into the filename entries from the line number information\ntable for the compilation unit containing this value.",51,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"into","","",0,null],[11,"from","","",0,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"into","","",1,null],[11,"from","","",1,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"clone","","",52,null],[11,"fmt","","",52,null],[11,"eq","","",52,null],[11,"ne","","",52,null],[11,"new","","Construct a new `DebugFrame` instance from the data in the\n`.debug_frame` section.",52,null],[11,"section_name","","",52,{"inputs":[],"output":{"name":"str"}}],[11,"from","","",52,null],[11,"clone","","",53,null],[11,"fmt","","",53,null],[11,"eq","","",53,null],[11,"ne","","",53,null],[11,"new","","Construct a new `EhFrame` instance from the data in the\n`.debug_frame` section.",53,null],[11,"section_name","","",53,{"inputs":[],"output":{"name":"str"}}],[11,"from","","",53,null],[11,"clone","","",2,null],[11,"default","","",2,{"inputs":[],"output":{"name":"baseaddresses"}}],[11,"fmt","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"set_cfi","","Set the CFI section base address.",2,null],[11,"set_text","","Set the `.text` section base address.",2,null],[11,"set_data","","Set the `.data` section base address.",2,null],[11,"clone","","",54,null],[11,"fmt","","",54,null],[11,"next","","Advance the iterator to the next entry.",54,null],[11,"next","","",54,null],[11,"clone","","",40,null],[11,"fmt","","",40,null],[11,"eq","","",40,null],[11,"ne","","",40,null],[11,"clone","","",55,null],[11,"fmt","","",55,null],[11,"eq","","",55,null],[11,"ne","","",55,null],[11,"default","","",55,{"inputs":[],"output":{"name":"augmentation"}}],[11,"clone","","",56,null],[11,"fmt","","",56,null],[11,"eq","","",56,null],[11,"ne","","",56,null],[11,"instructions","","Iterate over this CIE&#39;s initial instructions.",56,null],[11,"clone","","",57,null],[11,"fmt","","",57,null],[11,"eq","","",57,null],[11,"ne","","",57,null],[11,"parse","","Fully parse this FDE.",57,null],[11,"clone","","",58,null],[11,"fmt","","",58,null],[11,"eq","","",58,null],[11,"ne","","",58,null],[11,"cie","","Get a reference to this FDE&#39;s CIE.",58,null],[11,"instructions","","Iterate over this FDE&#39;s instructions.",58,null],[11,"contains","","Return `true` if the given address is within this FDE, `false`\notherwise.",58,null],[11,"lsda","","The address of this FDE&#39;s language-specific data area (LSDA), if it has\nany.",58,null],[11,"is_signal_trampoline","","Return true if this FDE&#39;s function is a trampoline for a signal handler.",58,null],[11,"personality","","Return the address of the FDE&#39;s function&#39;s personality routine\nhandler. The personality routine does language-specific clean up when\nunwinding the stack frames with the intent to not run them again.",58,null],[11,"clone","","",59,null],[11,"fmt","","",59,null],[11,"new","","Construct a new call frame unwinding context.",59,{"inputs":[],"output":{"name":"uninitializedunwindcontext"}}],[11,"initialize","","Run the CIE&#39;s initial instructions, creating an\n`InitializedUnwindContext`.",59,null],[11,"clone","","",60,null],[11,"fmt","","",60,null],[11,"reset","","Reset this context to the uninitialized state.",60,null],[11,"fmt","","",61,null],[11,"new","","Construct a new `UnwindTable` for the given\n`FrameDescriptionEntry`&#39;s CFI unwinding program.",61,{"inputs":[{"name":"initializedunwindcontext"},{"name":"framedescriptionentry"}],"output":{"name":"unwindtable"}}],[11,"next_row","","Evaluate call frame instructions until the next row of the table is\ncompleted, and return it.",61,null],[11,"fmt","","",62,null],[11,"clone","","",62,null],[11,"next","","",62,null],[11,"clone","","",63,null],[11,"fmt","","",63,null],[11,"eq","","",63,null],[11,"ne","","",63,null],[11,"default","","",63,{"inputs":[],"output":{"name":"self"}}],[11,"start_address","","Get the starting PC address that this row applies to.",63,null],[11,"end_address","","Get the end PC address where this row&#39;s register rules become\nunapplicable.",63,null],[11,"contains","","Return `true` if the given `address` is within this row&#39;s address range,\n`false` otherwise.",63,null],[11,"cfa","","Get the canonical frame address (CFA) recovery rule for this row.",63,null],[11,"register","","Get the register recovery rule for the given register number.",63,null],[11,"registers","","Iterate over all defined register `(number, rule)` pairs.",63,null],[11,"clone","","",41,null],[11,"fmt","","",41,null],[11,"eq","","",41,null],[11,"ne","","",41,null],[11,"default","","",41,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",42,null],[11,"fmt","","",42,null],[11,"eq","","",42,null],[11,"ne","","",42,null],[11,"clone","","",43,null],[11,"fmt","","",43,null],[11,"eq","","",43,null],[11,"ne","","",43,null],[11,"clone","","",64,null],[11,"fmt","","",64,null],[11,"next","","Parse the next call frame instruction.",64,null],[11,"next","","",64,null],[11,"fmt","","",3,null],[11,"clone","","",3,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"fmt","","",3,null],[11,"fmt","","",4,null],[11,"clone","","",4,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"fmt","","",4,null],[11,"fmt","","",5,null],[11,"clone","","",5,null],[11,"eq","","",5,null],[11,"ne","","",5,null],[11,"fmt","","",5,null],[11,"fmt","","",6,null],[11,"clone","","",6,null],[11,"eq","","",6,null],[11,"ne","","",6,null],[11,"fmt","","",6,null],[11,"fmt","","",7,null],[11,"clone","","",7,null],[11,"eq","","",7,null],[11,"ne","","",7,null],[11,"fmt","","",7,null],[11,"fmt","","",8,null],[11,"clone","","",8,null],[11,"eq","","",8,null],[11,"ne","","",8,null],[11,"fmt","","",8,null],[11,"fmt","","",9,null],[11,"clone","","",9,null],[11,"eq","","",9,null],[11,"ne","","",9,null],[11,"fmt","","",9,null],[11,"fmt","","",10,null],[11,"clone","","",10,null],[11,"eq","","",10,null],[11,"ne","","",10,null],[11,"fmt","","",10,null],[11,"fmt","","",11,null],[11,"clone","","",11,null],[11,"eq","","",11,null],[11,"ne","","",11,null],[11,"fmt","","",11,null],[11,"fmt","","",12,null],[11,"clone","","",12,null],[11,"eq","","",12,null],[11,"ne","","",12,null],[11,"fmt","","",12,null],[11,"fmt","","",13,null],[11,"clone","","",13,null],[11,"eq","","",13,null],[11,"ne","","",13,null],[11,"fmt","","",13,null],[11,"fmt","","",14,null],[11,"clone","","",14,null],[11,"eq","","",14,null],[11,"ne","","",14,null],[11,"fmt","","",14,null],[11,"fmt","","",15,null],[11,"clone","","",15,null],[11,"eq","","",15,null],[11,"ne","","",15,null],[11,"fmt","","",15,null],[11,"fmt","","",16,null],[11,"clone","","",16,null],[11,"eq","","",16,null],[11,"ne","","",16,null],[11,"fmt","","",16,null],[11,"fmt","","",17,null],[11,"clone","","",17,null],[11,"eq","","",17,null],[11,"ne","","",17,null],[11,"fmt","","",17,null],[11,"fmt","","",18,null],[11,"clone","","",18,null],[11,"eq","","",18,null],[11,"ne","","",18,null],[11,"fmt","","",18,null],[11,"fmt","","",19,null],[11,"clone","","",19,null],[11,"eq","","",19,null],[11,"ne","","",19,null],[11,"fmt","","",19,null],[11,"fmt","","",20,null],[11,"clone","","",20,null],[11,"eq","","",20,null],[11,"ne","","",20,null],[11,"fmt","","",20,null],[11,"fmt","","",21,null],[11,"clone","","",21,null],[11,"eq","","",21,null],[11,"ne","","",21,null],[11,"fmt","","",21,null],[11,"fmt","","",22,null],[11,"clone","","",22,null],[11,"eq","","",22,null],[11,"ne","","",22,null],[11,"fmt","","",22,null],[11,"fmt","","",23,null],[11,"clone","","",23,null],[11,"eq","","",23,null],[11,"ne","","",23,null],[11,"fmt","","",23,null],[11,"fmt","","",24,null],[11,"clone","","",24,null],[11,"eq","","",24,null],[11,"ne","","",24,null],[11,"fmt","","",24,null],[11,"format","","Get the pointer encoding&#39;s format.",24,null],[11,"application","","Get the pointer encoding&#39;s application.",24,null],[11,"is_absent","","Is this encoding the absent pointer encoding?",24,null],[11,"is_indirect","","Is this coding indirect? If so, its encoded value is the address of the\nreal pointer result, not the pointer result itself.",24,null],[11,"is_valid_encoding","","Is this a known, valid pointer encoding?",24,null],[11,"fmt","","",65,null],[11,"clone","","",65,null],[11,"eq","","",65,null],[11,"default","","",65,{"inputs":[],"output":{"name":"littleendian"}}],[11,"read_u16","","",65,null],[11,"read_u32","","",65,null],[11,"read_u64","","",65,null],[11,"read_uint","","",65,null],[11,"write_u16","","",65,null],[11,"write_u32","","",65,null],[11,"write_u64","","",65,null],[11,"write_uint","","",65,null],[11,"is_big_endian","","",65,{"inputs":[],"output":{"name":"bool"}}],[11,"fmt","","",66,null],[11,"clone","","",66,null],[11,"eq","","",66,null],[11,"default","","",66,{"inputs":[],"output":{"name":"bigendian"}}],[11,"read_u16","","",66,null],[11,"read_u32","","",66,null],[11,"read_u64","","",66,null],[11,"read_uint","","",66,null],[11,"write_u16","","",66,null],[11,"write_u32","","",66,null],[11,"write_u64","","",66,null],[11,"write_uint","","",66,null],[11,"is_big_endian","","",66,{"inputs":[],"output":{"name":"bool"}}],[11,"fmt","","",25,null],[11,"clone","","",25,null],[11,"eq","","",25,null],[11,"ne","","",25,null],[11,"new","","Construct a new `EndianBuf` with the given buffer.",25,null],[11,"split_at","","Split the buffer in two at the given index, resulting in the tuple where\nthe first item has range [0, idx), and the second has range\n[idx, len). Panics if the index is out of bounds.",25,null],[11,"try_split_at","","The same as `split_at`, but returns a `Result` rather than panicking\nwhen the index is out of bounds.",25,null],[11,"range","","Take the given `start..end` range of the underlying buffer and return a\nnew `EndianBuf`.",25,null],[11,"range_from","","Take the given `start..` range of the underlying buffer and return a new\n`EndianBuf`.",25,null],[11,"range_to","","Take the given `..end` range of the underlying buffer and return a new\n`EndianBuf`.",25,null],[11,"index","","",25,null],[11,"index","","",25,null],[11,"deref","","",25,null],[11,"into","","",25,null],[11,"fmt","","",44,null],[11,"clone","","",44,null],[11,"eq","","",44,null],[11,"ne","","",44,null],[11,"fmt","","",44,null],[11,"description","","",44,null],[11,"fmt","","",26,null],[11,"clone","","",26,null],[11,"eq","","",26,null],[11,"ne","","",26,null],[11,"fmt","","",45,null],[11,"clone","","",45,null],[11,"eq","","",45,null],[11,"fmt","","",27,null],[11,"clone","","",27,null],[11,"eq","","",27,null],[11,"ne","","",27,null],[11,"fmt","","",67,null],[11,"clone","","",67,null],[11,"new","","Construct a new `DebugAbbrev` instance from the data in the `.debug_abbrev`\nsection.",67,null],[11,"abbreviations","","Parse the abbreviations at the given `offset` within this\n`.debug_abbrev` section.",67,null],[11,"section_name","","",67,{"inputs":[],"output":{"name":"str"}}],[11,"from","","",67,null],[11,"fmt","","",68,null],[11,"default","","",68,{"inputs":[],"output":{"name":"abbreviations"}}],[11,"clone","","",68,null],[11,"get","","Get the abbreviation associated with the given code.",68,null],[11,"fmt","","",69,null],[11,"clone","","",69,null],[11,"eq","","",69,null],[11,"ne","","",69,null],[11,"new","","Construct a new `Abbreviation`.",69,{"inputs":[{"name":"u64"},{"name":"dwtag"},{"name":"dwchildren"},{"name":"vec"}],"output":{"name":"abbreviation"}}],[11,"code","","Get this abbreviation&#39;s code.",69,null],[11,"tag","","Get this abbreviation&#39;s tag.",69,null],[11,"has_children","","Return true if this abbreviation&#39;s type has children, false otherwise.",69,null],[11,"attributes","","Get this abbreviation&#39;s attributes.",69,null],[11,"fmt","","",70,null],[11,"clone","","",70,null],[11,"eq","","",70,null],[11,"ne","","",70,null],[11,"new","","Construct a new `AttributeSpecification` from the given name and form.",70,{"inputs":[{"name":"dwat"},{"name":"dwform"}],"output":{"name":"attributespecification"}}],[11,"name","","Get the attribute&#39;s name.",70,null],[11,"form","","Get the attribute&#39;s form.",70,null],[11,"size","","Return the size of the attribute, in bytes.",70,null],[11,"fmt","","",71,null],[11,"clone","","",71,null],[11,"segment","","Return the segment selector of this arange.",71,null],[11,"address","","Return the beginning address of this arange.",71,null],[11,"length","","Return the length of this arange.",71,null],[11,"debug_info_offset","","Return the offset into the .debug_info section for this arange.",71,null],[11,"eq","","",71,null],[11,"partial_cmp","","",71,null],[11,"cmp","","",71,null],[11,"fmt","","",28,null],[11,"clone","","",28,null],[11,"eq","","",28,null],[11,"ne","","",28,null],[11,"fmt","","",72,null],[11,"clone","","",72,null],[11,"new","","Construct a new `DebugLine` instance from the data in the `.debug_line`\nsection.",72,null],[11,"program","","Parse the line number program whose header is at the given `offset` in the\n`.debug_line` section.",72,null],[11,"section_name","","",72,{"inputs":[],"output":{"name":"str"}}],[11,"from","","",72,null],[11,"header","","",73,null],[11,"add_file","","",73,null],[11,"fmt","","",74,null],[11,"clone","","",74,null],[11,"header","","Get a reference to the header for this state machine&#39;s line number\nprogram.",74,null],[11,"next_row","","Parse and execute the next opcodes in the line number program until\nanother row in the line number matrix is computed.",74,null],[11,"run_to_address","","Parse and execute opcodes until we reach a row matching `addr`, the end of the program,\nor an error.",74,null],[11,"clone","","",46,null],[11,"fmt","","",46,null],[11,"eq","","",46,null],[11,"ne","","",46,null],[11,"fmt","","",46,null],[11,"clone","","",75,null],[11,"fmt","","",75,null],[11,"next_opcode","","Advance the iterator and return the next opcode.",75,null],[11,"clone","","",76,null],[11,"fmt","","",76,null],[11,"default","","",76,{"inputs":[],"output":{"name":"linenumberrow"}}],[11,"eq","","",76,null],[11,"ne","","",76,null],[11,"address","","&quot;The program-counter value corresponding to a machine instruction\ngenerated by the compiler.&quot;",76,null],[11,"op_index","","&gt; An unsigned integer representing the index of an operation within a VLIW\n&gt; instruction. The index of the first operation is 0. For non-VLIW\n&gt; architectures, this register will always be 0.\n&gt;\n&gt; The address and op_index registers, taken together, form an operation\n&gt; pointer that can reference any individual operation with the\n&gt; instruction stream.",76,null],[11,"file_index","","&quot;An unsigned integer indicating the identity of the source file\ncorresponding to a machine instruction.&quot;",76,null],[11,"file","","The source file corresponding to the current machine instruction.",76,null],[11,"line","","&quot;An unsigned integer indicating a source line number. Lines are numbered\nbeginning at 1. The compiler may emit the value 0 in cases where an\ninstruction cannot be attributed to any source line.&quot;",76,null],[11,"column","","&quot;An unsigned integer indicating a column number within a source\nline. Columns are numbered beginning at 1. The value 0 is reserved to\nindicate that a statement begins at the “left edge” of the line.&quot;",76,null],[11,"is_stmt","","&quot;A boolean indicating that the current instruction is a recommended\nbreakpoint location. A recommended breakpoint location is intended to\n“represent” a line, a statement and/or a semantically distinct subpart\nof a statement.&quot;",76,null],[11,"basic_block","","&quot;A boolean indicating that the current instruction is the beginning of a\nbasic block.&quot;",76,null],[11,"end_sequence","","&quot;A boolean indicating that the current address is that of the first byte\nafter the end of a sequence of target machine instructions. end_sequence\nterminates a sequence of lines; therefore other information in the same\nrow is not meaningful.&quot;",76,null],[11,"prologue_end","","&quot;A boolean indicating that the current address is one (of possibly many)\nwhere execution should be suspended for an entry breakpoint of a\nfunction.&quot;",76,null],[11,"epilogue_begin","","&quot;A boolean indicating that the current address is one (of possibly many)\nwhere execution should be suspended for an exit breakpoint of a\nfunction.&quot;",76,null],[11,"isa","","Tag for the current instruction set architecture.",76,null],[11,"discriminator","","&quot;An unsigned integer identifying the block to which the current\ninstruction belongs. Discriminator values are assigned arbitrarily by\nthe DWARF producer and serve to distinguish among multiple blocks that\nmay all be associated with the same source file, line, and column. Where\nonly one block exists for a given source position, the discriminator\nvalue should be zero.&quot;",76,null],[11,"clone","","",47,null],[11,"fmt","","",47,null],[11,"eq","","",47,null],[11,"ne","","",47,null],[11,"partial_cmp","","",47,null],[11,"lt","","",47,null],[11,"le","","",47,null],[11,"gt","","",47,null],[11,"ge","","",47,null],[11,"cmp","","",47,null],[11,"clone","","",29,null],[11,"fmt","","",29,null],[11,"clone","","",77,null],[11,"fmt","","",77,null],[11,"eq","","",77,null],[11,"ne","","",77,null],[11,"unit_length","","Return the length of the line number program and header, not including\nthe length of the encoded length itself.",77,null],[11,"version","","Get the version of this header&#39;s line program.",77,null],[11,"header_length","","Get the length of the encoded line number program header, not including\nthe length of the encoded length itself.",77,null],[11,"minimum_instruction_length","","Get the minimum instruction length any opcode in this header&#39;s line\nprogram may have.",77,null],[11,"maximum_operations_per_instruction","","Get the maximum number of operations each instruction in this header&#39;s\nline program may have.",77,null],[11,"default_is_stmt","","Get the default value of the `is_stmt` register for this header&#39;s line\nprogram.",77,null],[11,"line_base","","Get the line base for this header&#39;s line program.",77,null],[11,"line_range","","Get the line range for this header&#39;s line program.",77,null],[11,"opcode_base","","Get opcode base for this header&#39;s line program.",77,null],[11,"standard_opcode_lengths","","The byte lengths of each standard opcode in this header&#39;s line program.",77,null],[11,"include_directories","","Get the set of include directories for this header&#39;s line program.",77,null],[11,"directory","","The include directory with the given directory index.",77,null],[11,"file_names","","Get the list of source files that appear in this header&#39;s line program.",77,null],[11,"file","","The source file with the given file index.",77,null],[11,"raw_program_buf","","Get the raw, un-parsed `EndianBuf` containing this header&#39;s line number\nprogram.",77,null],[11,"opcodes","","Iterate over the opcodes in this header&#39;s line number program, parsing\nthem as we go.",77,null],[11,"clone","","",73,null],[11,"fmt","","",73,null],[11,"eq","","",73,null],[11,"ne","","",73,null],[11,"header","","Retrieve the `LineNumberProgramHeader` for this program.",73,null],[11,"rows","","Construct a new `StateMachine` for executing line programs and\ngenerating the line information matrix.",73,null],[11,"sequences","","Execute the line number program, completing the `IncompleteLineNumberProgram`\ninto a `CompleteLineNumberProgram` and producing an array of sequences within\nthe line number program that can later be used with\n`CompleteLineNumberProgram::resume_from`.",73,null],[11,"clone","","",78,null],[11,"fmt","","",78,null],[11,"eq","","",78,null],[11,"ne","","",78,null],[11,"header","","Retrieve the `LineNumberProgramHeader` for this program.",78,null],[11,"resume_from","","Construct a new `StateMachine` for executing the subset of the line\nnumber program identified by &#39;sequence&#39; and  generating the line information\nmatrix.",78,null],[11,"clone","","",79,null],[11,"fmt","","",79,null],[11,"eq","","",79,null],[11,"ne","","",79,null],[11,"path_name","","&gt; A null-terminated string containing the full or relative path name of\n&gt; a source file. If the entry contains a file name or a relative path\n&gt; name, the file is located relative to either the compilation directory\n&gt; (as specified by the DW_AT_comp_dir attribute given in the compilation\n&gt; unit) or one of the directories in the include_directories section.",79,null],[11,"directory_index","","&gt; An unsigned LEB128 number representing the directory index of the\n&gt; directory in which the file was found.\n&gt;\n&gt; ...\n&gt;\n&gt; The directory index represents an entry in the include_directories\n&gt; section of the line number program header. The index is 0 if the file\n&gt; was found in the current directory of the compilation, 1 if it was found\n&gt; in the first directory in the include_directories section, and so\n&gt; on. The directory index is ignored for file names that represent full\n&gt; path names.",79,null],[11,"directory","","Get this file&#39;s directory.",79,null],[11,"last_modification","","&quot;An unsigned LEB128 number representing the time of last modification of\nthe file, or 0 if not available.&quot;",79,null],[11,"length","","&quot;An unsigned LEB128 number representing the length in bytes of the file,\nor 0 if not available.&quot;",79,null],[11,"fmt","","",30,null],[11,"clone","","",30,null],[11,"eq","","",30,null],[11,"ne","","",30,null],[11,"fmt","","",80,null],[11,"clone","","",80,null],[11,"new","","Construct a new `DebugLoc` instance from the data in the `.debug_loc`\nsection.",80,null],[11,"locations","","Iterate over the `LocationListEntry`s starting at the given offset.",80,null],[11,"raw_locations","","Iterate over the raw `LocationListEntry`s starting at the given offset.",80,null],[11,"section_name","","",80,{"inputs":[],"output":{"name":"str"}}],[11,"from","","",80,null],[11,"fmt","","",81,null],[11,"new","","Construct a `RawLocationListIter`.",81,{"inputs":[{"name":"endianbuf"},{"name":"u8"}],"output":{"name":"rawlocationlistiter"}}],[11,"next","","Advance the iterator to the next location.",81,null],[11,"next","","",81,null],[11,"fmt","","",82,null],[11,"next","","Advance the iterator to the next location.",82,null],[11,"next","","",82,null],[11,"fmt","","",31,null],[11,"clone","","",31,null],[11,"eq","","",31,null],[11,"ne","","",31,null],[11,"fmt","","",48,null],[11,"clone","","",48,null],[11,"eq","","",48,null],[11,"ne","","",48,null],[11,"fmt","","",49,null],[11,"clone","","",49,null],[11,"eq","","",49,null],[11,"ne","","",49,null],[11,"fmt","","",50,null],[11,"clone","","",50,null],[11,"eq","","",50,null],[11,"ne","","",50,null],[11,"fmt","","",32,null],[11,"clone","","",32,null],[11,"eq","","",32,null],[11,"ne","","",32,null],[11,"parse","","Parse a single DWARF expression operation.",49,null],[11,"fmt","","",83,null],[11,"new","","Create a new DWARF expression evaluator.",83,null],[11,"set_initial_value","","Set an initial value to be pushed on the DWARF expression\nevaluator&#39;s stack.  This can be used in cases like\n`DW_AT_vtable_elem_location`, which require a value on the\nstack before evaluation commences.  If no initial value is\nset, and the expression uses an opcode requiring the initial\nvalue, then evaluation will fail with an error.",83,null],[11,"set_object_address","","Set the enclosing object&#39;s address, as used by\n`DW_OP_push_object_address`.  If no object address is set, and\nthe expression uses an opcode requiring the object address,\nthen evaluation will fail with an error.",83,null],[11,"set_max_iterations","","Set the maximum number of iterations to be allowed by the\nexpression evaluator.",83,null],[11,"evaluate","","Evaluate a DWARF expression.  If successful, the result will\nhold a vector of pieces, each describing a part of the final\nobject.",83,null],[11,"fmt","","",84,null],[11,"clone","","",84,null],[11,"name","","Returns the name this entry refers to.",84,null],[11,"info_offset","","Returns the offset into the .debug_info section for this name.",84,null],[11,"fmt","","",85,null],[11,"clone","","",85,null],[11,"name","","Returns the name of the type this entry refers to.",85,null],[11,"types_offset","","Returns the offset into the .debug_types section for this type.",85,null],[11,"fmt","","",33,null],[11,"clone","","",33,null],[11,"eq","","",33,null],[11,"ne","","",33,null],[11,"fmt","","",86,null],[11,"clone","","",86,null],[11,"new","","Construct a new `DebugRanges` instance from the data in the `.debug_ranges`\nsection.",86,null],[11,"ranges","","Iterate over the `Range` list entries starting at the given offset.",86,null],[11,"raw_ranges","","Iterate over the raw `Range` list entries starting at the given offset.",86,null],[11,"section_name","","",86,{"inputs":[],"output":{"name":"str"}}],[11,"from","","",86,null],[11,"fmt","","",87,null],[11,"next","","Advance the iterator to the next range.",87,null],[11,"next","","",87,null],[11,"fmt","","",88,null],[11,"next","","Advance the iterator to the next range.",88,null],[11,"next","","",88,null],[11,"fmt","","",34,null],[11,"clone","","",34,null],[11,"eq","","",34,null],[11,"ne","","",34,null],[11,"is_end","","Check if this is a range end entry.",34,null],[11,"is_base_address","","Check if this is a base address selection entry.",34,null],[11,"add_base_address","","Add a base address to this range.",34,null],[11,"fmt","","",35,null],[11,"clone","","",35,null],[11,"eq","","",35,null],[11,"ne","","",35,null],[11,"fmt","","",89,null],[11,"clone","","",89,null],[11,"new","","Construct a new `DebugStr` instance from the data in the `.debug_str`\nsection.",89,null],[11,"get_str","","Lookup a string from the `.debug_str` section by DebugStrOffset.",89,null],[11,"section_name","","",89,{"inputs":[],"output":{"name":"str"}}],[11,"from","","",89,null],[11,"fmt","","",38,null],[11,"clone","","",38,null],[11,"eq","","",38,null],[11,"ne","","",38,null],[11,"fmt","","",39,null],[11,"clone","","",39,null],[11,"eq","","",39,null],[11,"ne","","",39,null],[11,"fmt","","",36,null],[11,"clone","","",36,null],[11,"eq","","",36,null],[11,"ne","","",36,null],[11,"fmt","","",37,null],[11,"clone","","",37,null],[11,"eq","","",37,null],[11,"ne","","",37,null],[11,"cmp","","",37,null],[11,"partial_cmp","","",37,null],[11,"lt","","",37,null],[11,"le","","",37,null],[11,"gt","","",37,null],[11,"ge","","",37,null],[11,"fmt","","",90,null],[11,"clone","","",90,null],[11,"new","","Construct a new `DebugInfo` instance from the data in the `.debug_info`\nsection.",90,null],[11,"units","","Iterate the compilation- and partial-units in this\n`.debug_info` section.",90,null],[11,"header_from_offset","","Get the CompilationUnitHeader located at offset from this .debug_info section.",90,null],[11,"section_name","","",90,{"inputs":[],"output":{"name":"str"}}],[11,"from","","",90,null],[11,"clone","","",91,null],[11,"fmt","","",91,null],[11,"next","","Advance the iterator to the next unit header.",91,null],[11,"next","","",91,null],[11,"fmt","","",92,null],[11,"clone","","",92,null],[11,"eq","","",92,null],[11,"ne","","",92,null],[11,"size_of_header","","Return the serialized size of the compilation unit header for the given\nDWARF format.",92,{"inputs":[{"name":"format"}],"output":{"name":"usize"}}],[11,"offset","","Get the offset of this compilation unit within the .debug_info section.",92,null],[11,"unit_length","","Get the length of the debugging info for this compilation unit, not\nincluding the byte length of the encoded length itself.",92,null],[11,"length_including_self","","Get the length of the debugging info for this compilation unit,\nincluding the byte length of the encoded length itself.",92,null],[11,"version","","Get the DWARF version of the debugging info for this compilation unit.",92,null],[11,"debug_abbrev_offset","","The offset into the `.debug_abbrev` section for this compilation unit&#39;s\ndebugging information entries&#39; abbreviations.",92,null],[11,"address_size","","The size of addresses (in bytes) in this type-unit.",92,null],[11,"format","","Whether this type unit is encoded in 64- or 32-bit DWARF.",92,null],[11,"header_size","","The serialized size of the header for this compilation unit.",92,null],[11,"entries","","Navigate this compilation unit&#39;s `DebuggingInformationEntry`s.",92,null],[11,"entries_at_offset","","Navigate this compilation unit&#39;s `DebuggingInformationEntry`s\nstarting at the given offset.",92,null],[11,"entries_tree","","Navigate this compilation unit&#39;s `DebuggingInformationEntry`s as a tree\nstarting at the given offset.",92,null],[11,"abbreviations","","Parse this compilation unit&#39;s abbreviations.",92,null],[11,"clone","","",93,null],[11,"fmt","","",93,null],[11,"code","","Get this entry&#39;s code.",93,null],[11,"offset","","Get this entry&#39;s offset.",93,null],[11,"tag","","Get this entry&#39;s `DW_TAG_whatever` tag.",93,null],[11,"has_children","","Return true if this entry&#39;s type can have children, false otherwise.",93,null],[11,"attrs","","Iterate over this entry&#39;s set of attributes.",93,null],[11,"attr","","Find the first attribute in this entry which has the given name,\nand return it. Returns `Ok(None)` if no attribute is found.",93,null],[11,"attr_value_raw","","Find the first attribute in this entry which has the given name,\nand return its raw value. Returns `Ok(None)` if no attribute is found.",93,null],[11,"attr_value","","Find the first attribute in this entry which has the given name,\nand return its normalized value.  Returns `Ok(None)` if no\nattribute is found.",93,null],[11,"clone","","",51,null],[11,"fmt","","",51,null],[11,"eq","","",51,null],[11,"ne","","",51,null],[11,"clone","","",94,null],[11,"fmt","","",94,null],[11,"eq","","",94,null],[11,"ne","","",94,null],[11,"name","","Get this attribute&#39;s name.",94,null],[11,"raw_value","","Get this attribute&#39;s raw value.",94,null],[11,"value","","Get this attribute&#39;s normalized value.",94,null],[11,"u8_value","","Try to convert this attribute&#39;s value to a u8.",94,null],[11,"u16_value","","Try to convert this attribute&#39;s value to a u16.",94,null],[11,"udata_value","","Try to convert this attribute&#39;s value to an unsigned integer.",94,null],[11,"sdata_value","","Try to convert this attribute&#39;s value to a signed integer.",94,null],[11,"offset_value","","Try to convert this attribute&#39;s value to an offset.",94,null],[11,"string_value","","Try to return this attribute&#39;s value as a string reference.",94,null],[11,"clone","","",95,null],[11,"fmt","","",95,null],[11,"next","","Advance the iterator and return the next attribute.",95,null],[11,"next","","",95,null],[11,"clone","","",96,null],[11,"fmt","","",96,null],[11,"current","","Get a reference to the entry that the cursor is currently pointing to.",96,null],[11,"next_entry","","Move the cursor to the next DIE in the tree.",96,null],[11,"next_dfs","","Move the cursor to the next DIE in the tree in DFS order.",96,null],[11,"next_sibling","","Move the cursor to the next sibling DIE of the current one.",96,null],[11,"tree","","Return a tree view of the entries that have the current entry as the root.",96,null],[11,"clone","","",97,null],[11,"fmt","","",97,null],[11,"iter","","Returns an iterator for the entries that are children of the current entry.",97,null],[11,"fmt","","",98,null],[11,"entry","","Returns the current entry in the tree.",98,null],[11,"next","","Returns an iterator for the next child entry.",98,null],[11,"fmt","","",99,null],[11,"clone","","",99,null],[11,"new","","Construct a new `DebugTypes` instance from the data in the `.debug_types`\nsection.",99,null],[11,"units","","Iterate the type-units in this `.debug_types` section.",99,null],[11,"clone","","",100,null],[11,"fmt","","",100,null],[11,"next","","Advance the iterator to the next type unit header.",100,null],[11,"next","","",100,null],[11,"fmt","","",101,null],[11,"clone","","",101,null],[11,"eq","","",101,null],[11,"ne","","",101,null],[11,"size_of_header","","Return the serialized size of the type-unit header for the given\nDWARF format.",101,{"inputs":[{"name":"format"}],"output":{"name":"usize"}}],[11,"offset","","Get the offset of this compilation unit within the .debug_info section.",101,null],[11,"unit_length","","Get the length of the debugging info for this type-unit.",101,null],[11,"length_including_self","","Get the length of the debugging info for this type-unit,\nincluding the byte length of the encoded length itself.",101,null],[11,"version","","Get the DWARF version of the debugging info for this type-unit.",101,null],[11,"debug_abbrev_offset","","The offset into the `.debug_abbrev` section for this type-unit&#39;s\ndebugging information entries.",101,null],[11,"address_size","","The size of addresses (in bytes) in this type-unit.",101,null],[11,"format","","Whether this type unit is encoded in 64- or 32-bit DWARF.",101,null],[11,"header_size","","The serialized size of the header for this type-unit.",101,null],[11,"type_signature","","Get the unique type signature for this type unit.",101,null],[11,"type_offset","","Get the offset within this type unit where the type is defined.",101,null],[11,"entries","","Navigate this type unit&#39;s `DebuggingInformationEntry`s.",101,null],[11,"entries_at_offset","","Navigate this type unit&#39;s `DebuggingInformationEntry`s\nstarting at the given offset.",101,null],[11,"entries_tree","","Navigate this type unit&#39;s `DebuggingInformationEntry`s as a tree\nstarting at the given offset.",101,null],[11,"abbreviations","","Parse this type unit&#39;s abbreviations.",101,null],[6,"NativeEndian","","The native endianity for the target platform.",null,null],[6,"Result","","The result of a parse.",null,null],[6,"DebugAranges","","The `DebugAranges` struct represents the DWARF address range information\nfound in the `.debug_aranges` section.",null,null],[6,"ArangeEntryIter","","An iterator over the aranges from a `.debug_aranges` section.",null,null],[6,"DebugPubNames","","The `DebugPubNames` struct represents the DWARF public names information\nfound in the `.debug_pubnames` section.",null,null],[6,"PubNamesEntryIter","","An iterator over the pubnames from a `.debug_pubnames` section.",null,null],[6,"DebugPubTypes","","The `DebugPubTypes` struct represents the DWARF public types information\nfound in the `.debug_types` section.",null,null],[6,"PubTypesEntryIter","","An iterator over the pubtypes from a `.debug_pubtypes` section.",null,null],[17,"DW_CFA_advance_loc","","",null,null],[17,"DW_CFA_offset","","",null,null],[17,"DW_CFA_restore","","",null,null],[17,"DW_CFA_nop","","",null,null],[17,"DW_CFA_set_loc","","",null,null],[17,"DW_CFA_advance_loc1","","",null,null],[17,"DW_CFA_advance_loc2","","",null,null],[17,"DW_CFA_advance_loc4","","",null,null],[17,"DW_CFA_offset_extended","","",null,null],[17,"DW_CFA_restore_extended","","",null,null],[17,"DW_CFA_undefined","","",null,null],[17,"DW_CFA_same_value","","",null,null],[17,"DW_CFA_register","","",null,null],[17,"DW_CFA_remember_state","","",null,null],[17,"DW_CFA_restore_state","","",null,null],[17,"DW_CFA_def_cfa","","",null,null],[17,"DW_CFA_def_cfa_register","","",null,null],[17,"DW_CFA_def_cfa_offset","","",null,null],[17,"DW_CFA_def_cfa_expression","","",null,null],[17,"DW_CFA_expression","","",null,null],[17,"DW_CFA_offset_extended_sf","","",null,null],[17,"DW_CFA_def_cfa_sf","","",null,null],[17,"DW_CFA_def_cfa_offset_sf","","",null,null],[17,"DW_CFA_val_offset","","",null,null],[17,"DW_CFA_val_offset_sf","","",null,null],[17,"DW_CFA_val_expression","","",null,null],[17,"DW_CFA_lo_user","","",null,null],[17,"DW_CFA_hi_user","","",null,null],[17,"DW_CFA_MIPS_advance_loc8","","",null,null],[17,"DW_CFA_GNU_window_save","","",null,null],[17,"DW_CFA_GNU_args_size","","",null,null],[17,"DW_CFA_GNU_negative_offset_extended","","",null,null],[17,"DW_CHILDREN_no","","",null,null],[17,"DW_CHILDREN_yes","","",null,null],[17,"DW_TAG_null","","",null,null],[17,"DW_TAG_array_type","","",null,null],[17,"DW_TAG_class_type","","",null,null],[17,"DW_TAG_entry_point","","",null,null],[17,"DW_TAG_enumeration_type","","",null,null],[17,"DW_TAG_formal_parameter","","",null,null],[17,"DW_TAG_imported_declaration","","",null,null],[17,"DW_TAG_label","","",null,null],[17,"DW_TAG_lexical_block","","",null,null],[17,"DW_TAG_member","","",null,null],[17,"DW_TAG_pointer_type","","",null,null],[17,"DW_TAG_reference_type","","",null,null],[17,"DW_TAG_compile_unit","","",null,null],[17,"DW_TAG_string_type","","",null,null],[17,"DW_TAG_structure_type","","",null,null],[17,"DW_TAG_subroutine_type","","",null,null],[17,"DW_TAG_typedef","","",null,null],[17,"DW_TAG_union_type","","",null,null],[17,"DW_TAG_unspecified_parameters","","",null,null],[17,"DW_TAG_variant","","",null,null],[17,"DW_TAG_common_block","","",null,null],[17,"DW_TAG_common_inclusion","","",null,null],[17,"DW_TAG_inheritance","","",null,null],[17,"DW_TAG_inlined_subroutine","","",null,null],[17,"DW_TAG_module","","",null,null],[17,"DW_TAG_ptr_to_member_type","","",null,null],[17,"DW_TAG_set_type","","",null,null],[17,"DW_TAG_subrange_type","","",null,null],[17,"DW_TAG_with_stmt","","",null,null],[17,"DW_TAG_access_declaration","","",null,null],[17,"DW_TAG_base_type","","",null,null],[17,"DW_TAG_catch_block","","",null,null],[17,"DW_TAG_const_type","","",null,null],[17,"DW_TAG_constant","","",null,null],[17,"DW_TAG_enumerator","","",null,null],[17,"DW_TAG_file_type","","",null,null],[17,"DW_TAG_friend","","",null,null],[17,"DW_TAG_namelist","","",null,null],[17,"DW_TAG_namelist_item","","",null,null],[17,"DW_TAG_packed_type","","",null,null],[17,"DW_TAG_subprogram","","",null,null],[17,"DW_TAG_template_type_parameter","","",null,null],[17,"DW_TAG_template_value_parameter","","",null,null],[17,"DW_TAG_thrown_type","","",null,null],[17,"DW_TAG_try_block","","",null,null],[17,"DW_TAG_variant_part","","",null,null],[17,"DW_TAG_variable","","",null,null],[17,"DW_TAG_volatile_type","","",null,null],[17,"DW_TAG_dwarf_procedure","","",null,null],[17,"DW_TAG_restrict_type","","",null,null],[17,"DW_TAG_interface_type","","",null,null],[17,"DW_TAG_namespace","","",null,null],[17,"DW_TAG_imported_module","","",null,null],[17,"DW_TAG_unspecified_type","","",null,null],[17,"DW_TAG_partial_unit","","",null,null],[17,"DW_TAG_imported_unit","","",null,null],[17,"DW_TAG_condition","","",null,null],[17,"DW_TAG_shared_type","","",null,null],[17,"DW_TAG_type_unit","","",null,null],[17,"DW_TAG_rvalue_reference_type","","",null,null],[17,"DW_TAG_template_alias","","",null,null],[17,"DW_TAG_coarray_type","","",null,null],[17,"DW_TAG_generic_subrange","","",null,null],[17,"DW_TAG_dynamic_type","","",null,null],[17,"DW_TAG_atomic_type","","",null,null],[17,"DW_TAG_call_site","","",null,null],[17,"DW_TAG_call_site_parameter","","",null,null],[17,"DW_TAG_lo_user","","",null,null],[17,"DW_TAG_hi_user","","",null,null],[17,"DW_TAG_MIPS_loop","","",null,null],[17,"DW_TAG_HP_array_descriptor","","",null,null],[17,"DW_TAG_HP_Bliss_field","","",null,null],[17,"DW_TAG_HP_Bliss_field_set","","",null,null],[17,"DW_TAG_format_label","","",null,null],[17,"DW_TAG_function_template","","",null,null],[17,"DW_TAG_class_template","","",null,null],[17,"DW_TAG_GNU_BINCL","","",null,null],[17,"DW_TAG_GNU_EINCL","","",null,null],[17,"DW_TAG_GNU_template_template_param","","",null,null],[17,"DW_TAG_GNU_template_parameter_pack","","",null,null],[17,"DW_TAG_GNU_formal_parameter_pack","","",null,null],[17,"DW_TAG_GNU_call_site","","",null,null],[17,"DW_TAG_GNU_call_site_parameter","","",null,null],[17,"DW_TAG_APPLE_property","","",null,null],[17,"DW_TAG_SUN_function_template","","",null,null],[17,"DW_TAG_SUN_class_template","","",null,null],[17,"DW_TAG_SUN_struct_template","","",null,null],[17,"DW_TAG_SUN_union_template","","",null,null],[17,"DW_TAG_SUN_indirect_inheritance","","",null,null],[17,"DW_TAG_SUN_codeflags","","",null,null],[17,"DW_TAG_SUN_memop_info","","",null,null],[17,"DW_TAG_SUN_omp_child_func","","",null,null],[17,"DW_TAG_SUN_rtti_descriptor","","",null,null],[17,"DW_TAG_SUN_dtor_info","","",null,null],[17,"DW_TAG_SUN_dtor","","",null,null],[17,"DW_TAG_SUN_f90_interface","","",null,null],[17,"DW_TAG_SUN_fortran_vax_structure","","",null,null],[17,"DW_TAG_ALTIUM_circ_type","","",null,null],[17,"DW_TAG_ALTIUM_mwa_circ_type","","",null,null],[17,"DW_TAG_ALTIUM_rev_carry_type","","",null,null],[17,"DW_TAG_ALTIUM_rom","","",null,null],[17,"DW_TAG_upc_shared_type","","",null,null],[17,"DW_TAG_upc_strict_type","","",null,null],[17,"DW_TAG_upc_relaxed_type","","",null,null],[17,"DW_TAG_PGI_kanji_type","","",null,null],[17,"DW_TAG_PGI_interface_block","","",null,null],[17,"DW_TAG_BORLAND_property","","",null,null],[17,"DW_TAG_BORLAND_Delphi_string","","",null,null],[17,"DW_TAG_BORLAND_Delphi_dynamic_array","","",null,null],[17,"DW_TAG_BORLAND_Delphi_set","","",null,null],[17,"DW_TAG_BORLAND_Delphi_variant","","",null,null],[17,"DW_AT_null","","",null,null],[17,"DW_AT_sibling","","",null,null],[17,"DW_AT_location","","",null,null],[17,"DW_AT_name","","",null,null],[17,"DW_AT_ordering","","",null,null],[17,"DW_AT_byte_size","","",null,null],[17,"DW_AT_bit_offset","","",null,null],[17,"DW_AT_bit_size","","",null,null],[17,"DW_AT_stmt_list","","",null,null],[17,"DW_AT_low_pc","","",null,null],[17,"DW_AT_high_pc","","",null,null],[17,"DW_AT_language","","",null,null],[17,"DW_AT_discr","","",null,null],[17,"DW_AT_discr_value","","",null,null],[17,"DW_AT_visibility","","",null,null],[17,"DW_AT_import","","",null,null],[17,"DW_AT_string_length","","",null,null],[17,"DW_AT_common_reference","","",null,null],[17,"DW_AT_comp_dir","","",null,null],[17,"DW_AT_const_value","","",null,null],[17,"DW_AT_containing_type","","",null,null],[17,"DW_AT_default_value","","",null,null],[17,"DW_AT_inline","","",null,null],[17,"DW_AT_is_optional","","",null,null],[17,"DW_AT_lower_bound","","",null,null],[17,"DW_AT_producer","","",null,null],[17,"DW_AT_prototyped","","",null,null],[17,"DW_AT_return_addr","","",null,null],[17,"DW_AT_start_scope","","",null,null],[17,"DW_AT_bit_stride","","",null,null],[17,"DW_AT_upper_bound","","",null,null],[17,"DW_AT_abstract_origin","","",null,null],[17,"DW_AT_accessibility","","",null,null],[17,"DW_AT_address_class","","",null,null],[17,"DW_AT_artificial","","",null,null],[17,"DW_AT_base_types","","",null,null],[17,"DW_AT_calling_convention","","",null,null],[17,"DW_AT_count","","",null,null],[17,"DW_AT_data_member_location","","",null,null],[17,"DW_AT_decl_column","","",null,null],[17,"DW_AT_decl_file","","",null,null],[17,"DW_AT_decl_line","","",null,null],[17,"DW_AT_declaration","","",null,null],[17,"DW_AT_discr_list","","",null,null],[17,"DW_AT_encoding","","",null,null],[17,"DW_AT_external","","",null,null],[17,"DW_AT_frame_base","","",null,null],[17,"DW_AT_friend","","",null,null],[17,"DW_AT_identifier_case","","",null,null],[17,"DW_AT_macro_info","","",null,null],[17,"DW_AT_namelist_item","","",null,null],[17,"DW_AT_priority","","",null,null],[17,"DW_AT_segment","","",null,null],[17,"DW_AT_specification","","",null,null],[17,"DW_AT_static_link","","",null,null],[17,"DW_AT_type","","",null,null],[17,"DW_AT_use_location","","",null,null],[17,"DW_AT_variable_parameter","","",null,null],[17,"DW_AT_virtuality","","",null,null],[17,"DW_AT_vtable_elem_location","","",null,null],[17,"DW_AT_allocated","","",null,null],[17,"DW_AT_associated","","",null,null],[17,"DW_AT_data_location","","",null,null],[17,"DW_AT_byte_stride","","",null,null],[17,"DW_AT_entry_pc","","",null,null],[17,"DW_AT_use_UTF8","","",null,null],[17,"DW_AT_extension","","",null,null],[17,"DW_AT_ranges","","",null,null],[17,"DW_AT_trampoline","","",null,null],[17,"DW_AT_call_column","","",null,null],[17,"DW_AT_call_file","","",null,null],[17,"DW_AT_call_line","","",null,null],[17,"DW_AT_description","","",null,null],[17,"DW_AT_binary_scale","","",null,null],[17,"DW_AT_decimal_scale","","",null,null],[17,"DW_AT_small","","",null,null],[17,"DW_AT_decimal_sign","","",null,null],[17,"DW_AT_digit_count","","",null,null],[17,"DW_AT_picture_string","","",null,null],[17,"DW_AT_mutable","","",null,null],[17,"DW_AT_threads_scaled","","",null,null],[17,"DW_AT_explicit","","",null,null],[17,"DW_AT_object_pointer","","",null,null],[17,"DW_AT_endianity","","",null,null],[17,"DW_AT_elemental","","",null,null],[17,"DW_AT_pure","","",null,null],[17,"DW_AT_recursive","","",null,null],[17,"DW_AT_signature","","",null,null],[17,"DW_AT_main_subprogram","","",null,null],[17,"DW_AT_data_bit_offset","","",null,null],[17,"DW_AT_const_expr","","",null,null],[17,"DW_AT_enum_class","","",null,null],[17,"DW_AT_linkage_name","","",null,null],[17,"DW_AT_string_length_bit_size","","",null,null],[17,"DW_AT_string_length_byte_size","","",null,null],[17,"DW_AT_rank","","",null,null],[17,"DW_AT_str_offsets_base","","",null,null],[17,"DW_AT_addr_base","","",null,null],[17,"DW_AT_ranges_base","","",null,null],[17,"DW_AT_dwo_id","","",null,null],[17,"DW_AT_dwo_name","","",null,null],[17,"DW_AT_reference","","",null,null],[17,"DW_AT_rvalue_reference","","",null,null],[17,"DW_AT_macros","","",null,null],[17,"DW_AT_noreturn","","",null,null],[17,"DW_AT_lo_user","","",null,null],[17,"DW_AT_hi_user","","",null,null],[17,"DW_AT_MIPS_fde","","",null,null],[17,"DW_AT_MIPS_loop_begin","","",null,null],[17,"DW_AT_MIPS_tail_loop_begin","","",null,null],[17,"DW_AT_MIPS_epilog_begin","","",null,null],[17,"DW_AT_MIPS_loop_unroll_factor","","",null,null],[17,"DW_AT_MIPS_software_pipeline_depth","","",null,null],[17,"DW_AT_MIPS_linkage_name","","",null,null],[17,"DW_AT_MIPS_stride","","",null,null],[17,"DW_AT_MIPS_abstract_name","","",null,null],[17,"DW_AT_MIPS_clone_origin","","",null,null],[17,"DW_AT_MIPS_has_inlines","","",null,null],[17,"DW_AT_MIPS_stride_byte","","",null,null],[17,"DW_AT_MIPS_stride_elem","","",null,null],[17,"DW_AT_MIPS_ptr_dopetype","","",null,null],[17,"DW_AT_MIPS_allocatable_dopetype","","",null,null],[17,"DW_AT_MIPS_assumed_shape_dopetype","","",null,null],[17,"DW_AT_MIPS_assumed_size","","",null,null],[17,"DW_AT_INTEL_other_endian","","",null,null],[17,"DW_AT_sf_names","","",null,null],[17,"DW_AT_src_info","","",null,null],[17,"DW_AT_mac_info","","",null,null],[17,"DW_AT_src_coords","","",null,null],[17,"DW_AT_body_begin","","",null,null],[17,"DW_AT_body_end","","",null,null],[17,"DW_AT_GNU_vector","","",null,null],[17,"DW_AT_GNU_guarded_by","","",null,null],[17,"DW_AT_GNU_pt_guarded_by","","",null,null],[17,"DW_AT_GNU_guarded","","",null,null],[17,"DW_AT_GNU_pt_guarded","","",null,null],[17,"DW_AT_GNU_locks_excluded","","",null,null],[17,"DW_AT_GNU_exclusive_locks_required","","",null,null],[17,"DW_AT_GNU_shared_locks_required","","",null,null],[17,"DW_AT_GNU_odr_signature","","",null,null],[17,"DW_AT_GNU_template_name","","",null,null],[17,"DW_AT_GNU_call_site_value","","",null,null],[17,"DW_AT_GNU_call_site_data_value","","",null,null],[17,"DW_AT_GNU_call_site_target","","",null,null],[17,"DW_AT_GNU_call_site_target_clobbered","","",null,null],[17,"DW_AT_GNU_tail_call","","",null,null],[17,"DW_AT_GNU_all_tail_call_sites","","",null,null],[17,"DW_AT_GNU_all_call_sites","","",null,null],[17,"DW_AT_GNU_all_source_call_sites","","",null,null],[17,"DW_AT_GNU_macros","","",null,null],[17,"DW_AT_GNU_dwo_name","","",null,null],[17,"DW_AT_GNU_dwo_id","","",null,null],[17,"DW_AT_GNU_ranges_base","","",null,null],[17,"DW_AT_GNU_addr_base","","",null,null],[17,"DW_AT_GNU_pubnames","","",null,null],[17,"DW_AT_GNU_pubtypes","","",null,null],[17,"DW_AT_GNU_discriminator","","",null,null],[17,"DW_AT_SUN_template","","",null,null],[17,"DW_AT_SUN_alignment","","",null,null],[17,"DW_AT_SUN_vtable","","",null,null],[17,"DW_AT_SUN_count_guarantee","","",null,null],[17,"DW_AT_SUN_command_line","","",null,null],[17,"DW_AT_SUN_vbase","","",null,null],[17,"DW_AT_SUN_compile_options","","",null,null],[17,"DW_AT_SUN_language","","",null,null],[17,"DW_AT_SUN_browser_file","","",null,null],[17,"DW_AT_SUN_vtable_abi","","",null,null],[17,"DW_AT_SUN_func_offsets","","",null,null],[17,"DW_AT_SUN_cf_kind","","",null,null],[17,"DW_AT_SUN_vtable_index","","",null,null],[17,"DW_AT_SUN_omp_tpriv_addr","","",null,null],[17,"DW_AT_SUN_omp_child_func","","",null,null],[17,"DW_AT_SUN_func_offset","","",null,null],[17,"DW_AT_SUN_memop_type_ref","","",null,null],[17,"DW_AT_SUN_profile_id","","",null,null],[17,"DW_AT_SUN_memop_signature","","",null,null],[17,"DW_AT_SUN_obj_dir","","",null,null],[17,"DW_AT_SUN_obj_file","","",null,null],[17,"DW_AT_SUN_original_name","","",null,null],[17,"DW_AT_SUN_hwcprof_signature","","",null,null],[17,"DW_AT_SUN_amd64_parmdump","","",null,null],[17,"DW_AT_SUN_part_link_name","","",null,null],[17,"DW_AT_SUN_link_name","","",null,null],[17,"DW_AT_SUN_pass_with_const","","",null,null],[17,"DW_AT_SUN_return_with_const","","",null,null],[17,"DW_AT_SUN_import_by_name","","",null,null],[17,"DW_AT_SUN_f90_pointer","","",null,null],[17,"DW_AT_SUN_pass_by_ref","","",null,null],[17,"DW_AT_SUN_f90_allocatable","","",null,null],[17,"DW_AT_SUN_f90_assumed_shape_array","","",null,null],[17,"DW_AT_SUN_c_vla","","",null,null],[17,"DW_AT_SUN_return_value_ptr","","",null,null],[17,"DW_AT_SUN_dtor_start","","",null,null],[17,"DW_AT_SUN_dtor_length","","",null,null],[17,"DW_AT_SUN_dtor_state_initial","","",null,null],[17,"DW_AT_SUN_dtor_state_final","","",null,null],[17,"DW_AT_SUN_dtor_state_deltas","","",null,null],[17,"DW_AT_SUN_import_by_lname","","",null,null],[17,"DW_AT_SUN_f90_use_only","","",null,null],[17,"DW_AT_SUN_namelist_spec","","",null,null],[17,"DW_AT_SUN_is_omp_child_func","","",null,null],[17,"DW_AT_SUN_fortran_main_alias","","",null,null],[17,"DW_AT_SUN_fortran_based","","",null,null],[17,"DW_AT_ALTIUM_loclist","","",null,null],[17,"DW_AT_use_GNAT_descriptive_type","","",null,null],[17,"DW_AT_GNAT_descriptive_type","","",null,null],[17,"DW_AT_GNU_numerator","","",null,null],[17,"DW_AT_GNU_denominator","","",null,null],[17,"DW_AT_GNU_bias","","",null,null],[17,"DW_AT_upc_threads_scaled","","",null,null],[17,"DW_AT_PGI_lbase","","",null,null],[17,"DW_AT_PGI_soffset","","",null,null],[17,"DW_AT_PGI_lstride","","",null,null],[17,"DW_AT_BORLAND_property_read","","",null,null],[17,"DW_AT_BORLAND_property_write","","",null,null],[17,"DW_AT_BORLAND_property_implements","","",null,null],[17,"DW_AT_BORLAND_property_index","","",null,null],[17,"DW_AT_BORLAND_property_default","","",null,null],[17,"DW_AT_BORLAND_Delphi_unit","","",null,null],[17,"DW_AT_BORLAND_Delphi_class","","",null,null],[17,"DW_AT_BORLAND_Delphi_record","","",null,null],[17,"DW_AT_BORLAND_Delphi_metaclass","","",null,null],[17,"DW_AT_BORLAND_Delphi_constructor","","",null,null],[17,"DW_AT_BORLAND_Delphi_destructor","","",null,null],[17,"DW_AT_BORLAND_Delphi_anonymous_method","","",null,null],[17,"DW_AT_BORLAND_Delphi_interface","","",null,null],[17,"DW_AT_BORLAND_Delphi_ABI","","",null,null],[17,"DW_AT_BORLAND_Delphi_return","","",null,null],[17,"DW_AT_BORLAND_Delphi_frameptr","","",null,null],[17,"DW_AT_BORLAND_closure","","",null,null],[17,"DW_AT_LLVM_include_path","","",null,null],[17,"DW_AT_LLVM_config_macros","","",null,null],[17,"DW_AT_LLVM_isysroot","","",null,null],[17,"DW_AT_APPLE_optimized","","",null,null],[17,"DW_AT_APPLE_flags","","",null,null],[17,"DW_AT_APPLE_isa","","",null,null],[17,"DW_AT_APPLE_block","","",null,null],[17,"DW_AT_APPLE_major_runtime_vers","","",null,null],[17,"DW_AT_APPLE_runtime_class","","",null,null],[17,"DW_AT_APPLE_omit_frame_ptr","","",null,null],[17,"DW_AT_APPLE_property_name","","",null,null],[17,"DW_AT_APPLE_property_getter","","",null,null],[17,"DW_AT_APPLE_property_setter","","",null,null],[17,"DW_AT_APPLE_property_attribute","","",null,null],[17,"DW_AT_APPLE_objc_complete_type","","",null,null],[17,"DW_AT_APPLE_property","","",null,null],[17,"DW_FORM_null","","",null,null],[17,"DW_FORM_addr","","",null,null],[17,"DW_FORM_block2","","",null,null],[17,"DW_FORM_block4","","",null,null],[17,"DW_FORM_data2","","",null,null],[17,"DW_FORM_data4","","",null,null],[17,"DW_FORM_data8","","",null,null],[17,"DW_FORM_string","","",null,null],[17,"DW_FORM_block","","",null,null],[17,"DW_FORM_block1","","",null,null],[17,"DW_FORM_data1","","",null,null],[17,"DW_FORM_flag","","",null,null],[17,"DW_FORM_sdata","","",null,null],[17,"DW_FORM_strp","","",null,null],[17,"DW_FORM_udata","","",null,null],[17,"DW_FORM_ref_addr","","",null,null],[17,"DW_FORM_ref1","","",null,null],[17,"DW_FORM_ref2","","",null,null],[17,"DW_FORM_ref4","","",null,null],[17,"DW_FORM_ref8","","",null,null],[17,"DW_FORM_ref_udata","","",null,null],[17,"DW_FORM_indirect","","",null,null],[17,"DW_FORM_sec_offset","","",null,null],[17,"DW_FORM_exprloc","","",null,null],[17,"DW_FORM_flag_present","","",null,null],[17,"DW_FORM_ref_sig8","","",null,null],[17,"DW_FORM_GNU_addr_index","","",null,null],[17,"DW_FORM_GNU_str_index","","",null,null],[17,"DW_FORM_GNU_ref_alt","","",null,null],[17,"DW_FORM_GNU_strp_alt","","",null,null],[17,"DW_ATE_address","","",null,null],[17,"DW_ATE_boolean","","",null,null],[17,"DW_ATE_complex_float","","",null,null],[17,"DW_ATE_float","","",null,null],[17,"DW_ATE_signed","","",null,null],[17,"DW_ATE_signed_char","","",null,null],[17,"DW_ATE_unsigned","","",null,null],[17,"DW_ATE_unsigned_char","","",null,null],[17,"DW_ATE_imaginary_float","","",null,null],[17,"DW_ATE_packed_decimal","","",null,null],[17,"DW_ATE_numeric_string","","",null,null],[17,"DW_ATE_edited","","",null,null],[17,"DW_ATE_signed_fixed","","",null,null],[17,"DW_ATE_unsigned_fixed","","",null,null],[17,"DW_ATE_decimal_float","","",null,null],[17,"DW_ATE_UTF","","",null,null],[17,"DW_ATE_lo_user","","",null,null],[17,"DW_ATE_hi_user","","",null,null],[17,"DW_DS_unsigned","","",null,null],[17,"DW_DS_leading_overpunch","","",null,null],[17,"DW_DS_trailing_overpunch","","",null,null],[17,"DW_DS_leading_separate","","",null,null],[17,"DW_DS_trailing_separate","","",null,null],[17,"DW_END_public","","",null,null],[17,"DW_END_protected","","",null,null],[17,"DW_END_private","","",null,null],[17,"DW_END_lo_user","","",null,null],[17,"DW_END_hi_user","","",null,null],[17,"DW_ACCESS_public","","",null,null],[17,"DW_ACCESS_protected","","",null,null],[17,"DW_ACCESS_private","","",null,null],[17,"DW_VIS_local","","",null,null],[17,"DW_VIS_exported","","",null,null],[17,"DW_VIS_qualified","","",null,null],[17,"DW_VIRTUALITY_none","","",null,null],[17,"DW_VIRTUALITY_virtual","","",null,null],[17,"DW_VIRTUALITY_pure_virtual","","",null,null],[17,"DW_LANG_C89","","",null,null],[17,"DW_LANG_C","","",null,null],[17,"DW_LANG_Ada83","","",null,null],[17,"DW_LANG_C_plus_plus","","",null,null],[17,"DW_LANG_Cobol74","","",null,null],[17,"DW_LANG_Cobol85","","",null,null],[17,"DW_LANG_Fortran77","","",null,null],[17,"DW_LANG_Fortran90","","",null,null],[17,"DW_LANG_Pascal83","","",null,null],[17,"DW_LANG_Modula2","","",null,null],[17,"DW_LANG_Java","","",null,null],[17,"DW_LANG_C99","","",null,null],[17,"DW_LANG_Ada95","","",null,null],[17,"DW_LANG_Fortran95","","",null,null],[17,"DW_LANG_PLI","","",null,null],[17,"DW_LANG_ObjC","","",null,null],[17,"DW_LANG_ObjC_plus_plus","","",null,null],[17,"DW_LANG_UPC","","",null,null],[17,"DW_LANG_D","","",null,null],[17,"DW_LANG_Python","","",null,null],[17,"DW_LANG_OpenCL","","",null,null],[17,"DW_LANG_Go","","",null,null],[17,"DW_LANG_Modula3","","",null,null],[17,"DW_LANG_Haskell","","",null,null],[17,"DW_LANG_C_plus_plus_03","","",null,null],[17,"DW_LANG_C_plus_plus_11","","",null,null],[17,"DW_LANG_OCaml","","",null,null],[17,"DW_LANG_Rust","","",null,null],[17,"DW_LANG_C11","","",null,null],[17,"DW_LANG_Swift","","",null,null],[17,"DW_LANG_Julia","","",null,null],[17,"DW_LANG_Dylan","","",null,null],[17,"DW_LANG_C_plus_plus_14","","",null,null],[17,"DW_LANG_Fortran03","","",null,null],[17,"DW_LANG_Fortran08","","",null,null],[17,"DW_LANG_lo_user","","",null,null],[17,"DW_LANG_hi_user","","",null,null],[17,"DW_LANG_Mips_Assembler","","",null,null],[17,"DW_LANG_GOOGLE_RenderScript","","",null,null],[17,"DW_LANG_SUN_Assembler","","",null,null],[17,"DW_LANG_ALTIUM_Assembler","","",null,null],[17,"DW_LANG_BORLAND_Delphi","","",null,null],[17,"DW_ADDR_none","","",null,null],[17,"DW_ID_case_sensitive","","",null,null],[17,"DW_ID_up_case","","",null,null],[17,"DW_ID_down_case","","",null,null],[17,"DW_ID_case_insensitive","","",null,null],[17,"DW_CC_normal","","",null,null],[17,"DW_CC_program","","",null,null],[17,"DW_CC_nocall","","",null,null],[17,"DW_CC_lo_user","","",null,null],[17,"DW_CC_hi_user","","",null,null],[17,"DW_INL_not_inlined","","",null,null],[17,"DW_INL_inlined","","",null,null],[17,"DW_INL_declared_not_inlined","","",null,null],[17,"DW_INL_declared_inlined","","",null,null],[17,"DW_ORD_row_major","","",null,null],[17,"DW_ORD_col_major","","",null,null],[17,"DW_DSC_label","","",null,null],[17,"DW_DSC_range","","",null,null],[17,"DW_LNS_copy","","",null,null],[17,"DW_LNS_advance_pc","","",null,null],[17,"DW_LNS_advance_line","","",null,null],[17,"DW_LNS_set_file","","",null,null],[17,"DW_LNS_set_column","","",null,null],[17,"DW_LNS_negate_stmt","","",null,null],[17,"DW_LNS_set_basic_block","","",null,null],[17,"DW_LNS_const_add_pc","","",null,null],[17,"DW_LNS_fixed_advance_pc","","",null,null],[17,"DW_LNS_set_prologue_end","","",null,null],[17,"DW_LNS_set_epilogue_begin","","",null,null],[17,"DW_LNS_set_isa","","",null,null],[17,"DW_LNE_end_sequence","","",null,null],[17,"DW_LNE_set_address","","",null,null],[17,"DW_LNE_define_file","","",null,null],[17,"DW_LNE_set_discriminator","","",null,null],[17,"DW_LNE_lo_user","","",null,null],[17,"DW_LNE_hi_user","","",null,null],[17,"DW_OP_addr","","",null,null],[17,"DW_OP_deref","","",null,null],[17,"DW_OP_const1u","","",null,null],[17,"DW_OP_const1s","","",null,null],[17,"DW_OP_const2u","","",null,null],[17,"DW_OP_const2s","","",null,null],[17,"DW_OP_const4u","","",null,null],[17,"DW_OP_const4s","","",null,null],[17,"DW_OP_const8u","","",null,null],[17,"DW_OP_const8s","","",null,null],[17,"DW_OP_constu","","",null,null],[17,"DW_OP_consts","","",null,null],[17,"DW_OP_dup","","",null,null],[17,"DW_OP_drop","","",null,null],[17,"DW_OP_over","","",null,null],[17,"DW_OP_pick","","",null,null],[17,"DW_OP_swap","","",null,null],[17,"DW_OP_rot","","",null,null],[17,"DW_OP_xderef","","",null,null],[17,"DW_OP_abs","","",null,null],[17,"DW_OP_and","","",null,null],[17,"DW_OP_div","","",null,null],[17,"DW_OP_minus","","",null,null],[17,"DW_OP_mod","","",null,null],[17,"DW_OP_mul","","",null,null],[17,"DW_OP_neg","","",null,null],[17,"DW_OP_not","","",null,null],[17,"DW_OP_or","","",null,null],[17,"DW_OP_plus","","",null,null],[17,"DW_OP_plus_uconst","","",null,null],[17,"DW_OP_shl","","",null,null],[17,"DW_OP_shr","","",null,null],[17,"DW_OP_shra","","",null,null],[17,"DW_OP_xor","","",null,null],[17,"DW_OP_bra","","",null,null],[17,"DW_OP_eq","","",null,null],[17,"DW_OP_ge","","",null,null],[17,"DW_OP_gt","","",null,null],[17,"DW_OP_le","","",null,null],[17,"DW_OP_lt","","",null,null],[17,"DW_OP_ne","","",null,null],[17,"DW_OP_skip","","",null,null],[17,"DW_OP_lit0","","",null,null],[17,"DW_OP_lit1","","",null,null],[17,"DW_OP_lit2","","",null,null],[17,"DW_OP_lit3","","",null,null],[17,"DW_OP_lit4","","",null,null],[17,"DW_OP_lit5","","",null,null],[17,"DW_OP_lit6","","",null,null],[17,"DW_OP_lit7","","",null,null],[17,"DW_OP_lit8","","",null,null],[17,"DW_OP_lit9","","",null,null],[17,"DW_OP_lit10","","",null,null],[17,"DW_OP_lit11","","",null,null],[17,"DW_OP_lit12","","",null,null],[17,"DW_OP_lit13","","",null,null],[17,"DW_OP_lit14","","",null,null],[17,"DW_OP_lit15","","",null,null],[17,"DW_OP_lit16","","",null,null],[17,"DW_OP_lit17","","",null,null],[17,"DW_OP_lit18","","",null,null],[17,"DW_OP_lit19","","",null,null],[17,"DW_OP_lit20","","",null,null],[17,"DW_OP_lit21","","",null,null],[17,"DW_OP_lit22","","",null,null],[17,"DW_OP_lit23","","",null,null],[17,"DW_OP_lit24","","",null,null],[17,"DW_OP_lit25","","",null,null],[17,"DW_OP_lit26","","",null,null],[17,"DW_OP_lit27","","",null,null],[17,"DW_OP_lit28","","",null,null],[17,"DW_OP_lit29","","",null,null],[17,"DW_OP_lit30","","",null,null],[17,"DW_OP_lit31","","",null,null],[17,"DW_OP_reg0","","",null,null],[17,"DW_OP_reg1","","",null,null],[17,"DW_OP_reg2","","",null,null],[17,"DW_OP_reg3","","",null,null],[17,"DW_OP_reg4","","",null,null],[17,"DW_OP_reg5","","",null,null],[17,"DW_OP_reg6","","",null,null],[17,"DW_OP_reg7","","",null,null],[17,"DW_OP_reg8","","",null,null],[17,"DW_OP_reg9","","",null,null],[17,"DW_OP_reg10","","",null,null],[17,"DW_OP_reg11","","",null,null],[17,"DW_OP_reg12","","",null,null],[17,"DW_OP_reg13","","",null,null],[17,"DW_OP_reg14","","",null,null],[17,"DW_OP_reg15","","",null,null],[17,"DW_OP_reg16","","",null,null],[17,"DW_OP_reg17","","",null,null],[17,"DW_OP_reg18","","",null,null],[17,"DW_OP_reg19","","",null,null],[17,"DW_OP_reg20","","",null,null],[17,"DW_OP_reg21","","",null,null],[17,"DW_OP_reg22","","",null,null],[17,"DW_OP_reg23","","",null,null],[17,"DW_OP_reg24","","",null,null],[17,"DW_OP_reg25","","",null,null],[17,"DW_OP_reg26","","",null,null],[17,"DW_OP_reg27","","",null,null],[17,"DW_OP_reg28","","",null,null],[17,"DW_OP_reg29","","",null,null],[17,"DW_OP_reg30","","",null,null],[17,"DW_OP_reg31","","",null,null],[17,"DW_OP_breg0","","",null,null],[17,"DW_OP_breg1","","",null,null],[17,"DW_OP_breg2","","",null,null],[17,"DW_OP_breg3","","",null,null],[17,"DW_OP_breg4","","",null,null],[17,"DW_OP_breg5","","",null,null],[17,"DW_OP_breg6","","",null,null],[17,"DW_OP_breg7","","",null,null],[17,"DW_OP_breg8","","",null,null],[17,"DW_OP_breg9","","",null,null],[17,"DW_OP_breg10","","",null,null],[17,"DW_OP_breg11","","",null,null],[17,"DW_OP_breg12","","",null,null],[17,"DW_OP_breg13","","",null,null],[17,"DW_OP_breg14","","",null,null],[17,"DW_OP_breg15","","",null,null],[17,"DW_OP_breg16","","",null,null],[17,"DW_OP_breg17","","",null,null],[17,"DW_OP_breg18","","",null,null],[17,"DW_OP_breg19","","",null,null],[17,"DW_OP_breg20","","",null,null],[17,"DW_OP_breg21","","",null,null],[17,"DW_OP_breg22","","",null,null],[17,"DW_OP_breg23","","",null,null],[17,"DW_OP_breg24","","",null,null],[17,"DW_OP_breg25","","",null,null],[17,"DW_OP_breg26","","",null,null],[17,"DW_OP_breg27","","",null,null],[17,"DW_OP_breg28","","",null,null],[17,"DW_OP_breg29","","",null,null],[17,"DW_OP_breg30","","",null,null],[17,"DW_OP_breg31","","",null,null],[17,"DW_OP_regx","","",null,null],[17,"DW_OP_fbreg","","",null,null],[17,"DW_OP_bregx","","",null,null],[17,"DW_OP_piece","","",null,null],[17,"DW_OP_deref_size","","",null,null],[17,"DW_OP_xderef_size","","",null,null],[17,"DW_OP_nop","","",null,null],[17,"DW_OP_push_object_address","","",null,null],[17,"DW_OP_call2","","",null,null],[17,"DW_OP_call4","","",null,null],[17,"DW_OP_call_ref","","",null,null],[17,"DW_OP_form_tls_address","","",null,null],[17,"DW_OP_call_frame_cfa","","",null,null],[17,"DW_OP_bit_piece","","",null,null],[17,"DW_OP_implicit_value","","",null,null],[17,"DW_OP_stack_value","","",null,null],[17,"DW_OP_implicit_pointer","","",null,null],[17,"DW_OP_entry_value","","",null,null],[17,"DW_OP_GNU_push_tls_address","","",null,null],[17,"DW_OP_GNU_implicit_pointer","","",null,null],[17,"DW_OP_GNU_entry_value","","",null,null],[17,"DW_EH_PE_uleb128","","",null,null],[17,"DW_EH_PE_udata2","","",null,null],[17,"DW_EH_PE_udata4","","",null,null],[17,"DW_EH_PE_udata8","","",null,null],[17,"DW_EH_PE_sleb128","","",null,null],[17,"DW_EH_PE_sdata2","","",null,null],[17,"DW_EH_PE_sdata4","","",null,null],[17,"DW_EH_PE_sdata8","","",null,null],[17,"DW_EH_PE_pcrel","","",null,null],[17,"DW_EH_PE_textrel","","",null,null],[17,"DW_EH_PE_datarel","","",null,null],[17,"DW_EH_PE_funcrel","","",null,null],[17,"DW_EH_PE_aligned","","",null,null],[17,"DW_EH_PE_indirect","","",null,null],[17,"DW_EH_PE_absptr","","",null,null],[17,"DW_EH_PE_omit","","",null,null],[8,"UnwindSection","","A section holding unwind information: either `.debug_frame` or\n`.eh_frame`. See [`DebugFrame`](./struct.DebugFrame.html) and\n[`EhFrame`](./struct.EhFrame.html) respectively.",null,null],[16,"Offset","","The offset type associated with this CFI section. Either\n`DebugFrameOffset` or `EhFrameOffset`.",102,null],[11,"offset","","Construct a `Self::Offset`.",102,null],[11,"entries","","Iterate over the `CommonInformationEntry`s and `FrameDescriptionEntry`s\nin this `.debug_frame` section.",102,null],[11,"cie_from_offset","","Parse the `CommonInformationEntry` at the given offset.",102,null],[11,"unwind_info_for_address","","Find the frame unwind information for the given address.",102,null],[8,"Endianity","","A trait describing the endianity of some buffer.",null,null],[10,"is_big_endian","","Return true for big endian byte order.",103,{"inputs":[],"output":{"name":"bool"}}],[11,"is_little_endian","","Return true for little endian byte order.",103,{"inputs":[],"output":{"name":"bool"}}],[8,"LineNumberProgram","","A `LineNumberProgram` provides access to a `LineNumberProgramHeader` and\na way to add files to the files table if necessary. Gimli consumers should\nnever need to use or see this trait.",null,null],[10,"header","","Get a reference to the held `LineNumberProgramHeader`.",104,null],[10,"add_file","","Add a file to the file table if necessary.",104,null],[8,"EvaluationContext","","Supply information to a DWARF expression evaluation.",null,null],[16,"ContextError","","The error type returned by the callback functions.",105,null],[10,"read_memory","","Read the indicated number of bytes from memory at the\nindicated address.  The number of bytes is guaranteed to be\nless than the word size of the target architecture.",105,null],[10,"read_register","","Read the indicated register and return its value.",105,null],[10,"frame_base","","Compute the frame base using `DW_AT_frame_base`.",105,null],[10,"read_tls","","Compute the address of a thread-local variable.",105,null],[10,"call_frame_cfa","","Compute the call frame CFA.",105,null],[10,"get_at_location","","Find the `DW_AT_location` attribute of the given DIE and\nreturn the corresponding DWARF expression.  If no expression\ncan be found, this should return an empty slice.",105,null],[10,"evaluate_entry_value","","Evaluate an expression at the entry to the current subprogram.",105,null],[8,"Section","","A convenience trait for loading DWARF sections from object files.  To be\nused like:",null,null],[10,"section_name","","Returns the ELF section name for this type.",106,{"inputs":[],"output":{"name":"str"}}],[11,"offset","","Construct a `Self::Offset`.",102,null],[11,"entries","","Iterate over the `CommonInformationEntry`s and `FrameDescriptionEntry`s\nin this `.debug_frame` section.",102,null],[11,"cie_from_offset","","Parse the `CommonInformationEntry` at the given offset.",102,null],[11,"unwind_info_for_address","","Find the frame unwind information for the given address.",102,null],[11,"is_little_endian","","Return true for little endian byte order.",103,{"inputs":[],"output":{"name":"bool"}}],[11,"section_name","","",107,{"inputs":[],"output":{"name":"str"}}],[11,"from","","",107,null],[11,"section_name","","",108,{"inputs":[],"output":{"name":"str"}}],[11,"from","","",108,null],[11,"section_name","","",109,{"inputs":[],"output":{"name":"str"}}],[11,"from","","",109,null]],"paths":[[3,"DebugFrameOffset"],[3,"EhFrameOffset"],[3,"BaseAddresses"],[3,"DwCfa"],[3,"DwChildren"],[3,"DwTag"],[3,"DwAt"],[3,"DwForm"],[3,"DwAte"],[3,"DwDs"],[3,"DwEnd"],[3,"DwAccess"],[3,"DwVis"],[3,"DwVirtuality"],[3,"DwLang"],[3,"DwAddr"],[3,"DwId"],[3,"DwCc"],[3,"DwInl"],[3,"DwOrd"],[3,"DwDsc"],[3,"DwLns"],[3,"DwLne"],[3,"DwOp"],[3,"DwEhPe"],[3,"EndianBuf"],[3,"DebugMacinfoOffset"],[3,"DebugAbbrevOffset"],[3,"DebugLineOffset"],[3,"LineNumberSequence"],[3,"DebugLocOffset"],[3,"LocationListEntry"],[3,"Piece"],[3,"DebugRangesOffset"],[3,"Range"],[3,"DebugStrOffset"],[3,"DebugInfoOffset"],[3,"UnitOffset"],[3,"DebugTypesOffset"],[3,"DebugTypeSignature"],[4,"CieOrFde"],[4,"CfaRule"],[4,"RegisterRule"],[4,"CallFrameInstruction"],[4,"Error"],[4,"Format"],[4,"Opcode"],[4,"ColumnType"],[4,"DieReference"],[4,"Operation"],[4,"Location"],[4,"AttributeValue"],[3,"DebugFrame"],[3,"EhFrame"],[3,"CfiEntriesIter"],[3,"Augmentation"],[3,"CommonInformationEntry"],[3,"PartialFrameDescriptionEntry"],[3,"FrameDescriptionEntry"],[3,"UninitializedUnwindContext"],[3,"InitializedUnwindContext"],[3,"UnwindTable"],[3,"RegisterRuleIter"],[3,"UnwindTableRow"],[3,"CallFrameInstructionIter"],[4,"LittleEndian"],[4,"BigEndian"],[3,"DebugAbbrev"],[3,"Abbreviations"],[3,"Abbreviation"],[3,"AttributeSpecification"],[3,"ArangeEntry"],[3,"DebugLine"],[3,"IncompleteLineNumberProgram"],[3,"StateMachine"],[3,"OpcodesIter"],[3,"LineNumberRow"],[3,"LineNumberProgramHeader"],[3,"CompleteLineNumberProgram"],[3,"FileEntry"],[3,"DebugLoc"],[3,"RawLocationListIter"],[3,"LocationListIter"],[3,"Evaluation"],[3,"PubNamesEntry"],[3,"PubTypesEntry"],[3,"DebugRanges"],[3,"RawRangesIter"],[3,"RangesIter"],[3,"DebugStr"],[3,"DebugInfo"],[3,"CompilationUnitHeadersIter"],[3,"CompilationUnitHeader"],[3,"DebuggingInformationEntry"],[3,"Attribute"],[3,"AttrsIter"],[3,"EntriesCursor"],[3,"EntriesTree"],[3,"EntriesTreeIter"],[3,"DebugTypes"],[3,"TypeUnitHeadersIter"],[3,"TypeUnitHeader"],[8,"UnwindSection"],[8,"Endianity"],[8,"LineNumberProgram"],[8,"EvaluationContext"],[8,"Section"],[6,"DebugAranges"],[6,"DebugPubNames"],[6,"DebugPubTypes"]]};
searchIndex["leb128"] = {"doc":"Read and write DWARF&#39;s &quot;Little Endian Base 128&quot; (LEB128) variable length\ninteger encoding.","items":[[0,"read","leb128","A module for reading signed and unsigned integers that have been LEB128\nencoded.",null,null],[4,"Error","leb128::read","An enumeration of the possible errors that can occur when reading a\nnumber encoded with LEB128.",null,null],[13,"IoError","","There was an underlying IO error.",0,null],[13,"Overflow","","The number being read is larger than can be represented.",0,null],[5,"unsigned","","Read an unsigned LEB128 number from the given `std::io::Read`able and\nreturn it or an error if reading failed.",null,{"inputs":[{"name":"r"}],"output":{"name":"result"}}],[5,"signed","","Read a signed LEB128 number from the given `std::io::Read`able and\nreturn it or an error if reading failed.",null,{"inputs":[{"name":"r"}],"output":{"name":"result"}}],[11,"fmt","","",0,null],[11,"from","","",0,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"fmt","","",0,null],[11,"description","","",0,null],[11,"cause","","",0,null],[0,"write","leb128","A module for writing integers encoded as LEB128.",null,null],[5,"unsigned","leb128::write","Write the given unsigned number using the LEB128 encoding to the given\n`std::io::Write`able. Returns the number of bytes written to `w`, or an\nerror if writing failed.",null,{"inputs":[{"name":"w"},{"name":"u64"}],"output":{"name":"result"}}],[5,"signed","","Write the given signed number using the LEB128 encoding to the given\n`std::io::Write`able. Returns the number of bytes written to `w`, or an\nerror if writing failed.",null,{"inputs":[{"name":"w"},{"name":"i64"}],"output":{"name":"result"}}]],"paths":[[4,"Error"]]};
searchIndex["nodrop"] = {"doc":"","items":[[3,"NoDrop","nodrop","A type holding **T** that will not call its destructor on drop",null,null],[11,"new","","Create a new **NoDrop**.",0,{"inputs":[{"name":"t"}],"output":{"name":"nodrop"}}],[11,"into_inner","","Extract the inner value.",0,null],[11,"drop","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null]],"paths":[[3,"NoDrop"]]};
searchIndex["odds"] = {"doc":"Odds and ends — collection miscellania.","items":[[3,"Fix","odds","Fixpoint combinator for rust closures, generalized over the return type.",null,null],[12,"0","","",0,null],[5,"fix","","Fixpoint combinator for rust closures, generalized over the return type.",null,{"inputs":[{"name":"t"},{"name":"f"}],"output":{"name":"r"}}],[5,"ref_eq","","Compare if **a** and **b** are equal *as pointers*.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"bool"}}],[5,"ptr_eq","","Compare if **a** and **b** are equal pointers.",null,null],[5,"raw_byte_repr","","Safe to use with any wholly initialized memory `ptr`",null,null],[5,"get_unchecked","","Use `debug_assert!` to check indexing in debug mode. In release mode, no checks are done.",null,null],[5,"get_unchecked_mut","","Use `debug_assert!` to check indexing in debug mode. In release mode, no checks are done.",null,null],[5,"debug_assert_unreachable","","Act as `debug_assert!` in debug mode, asserting that this point is not reached.",null,null],[5,"slice_unchecked","","Check slicing bounds in debug mode, otherwise just act as an unchecked\nslice call.",null,null],[5,"slice_unchecked_mut","","Check slicing bounds in debug mode, otherwise just act as an unchecked\nslice call.",null,null],[5,"ref_slice","","Create a length 1 slice out of a reference",null,null],[5,"ref_slice_mut","","Create a length 1 mutable slice out of a reference",null,null],[11,"call","","",0,null],[11,"clone","","",0,null],[0,"char","","Extra functions for `char`",null,null],[3,"EncodeUtf8Error","odds::char","Placeholder",null,null],[5,"encode_utf8","","Encode a char into buf using UTF-8.",null,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[0,"string","odds","Extensions to `&amp;str` and `String`",null,null],[3,"Prefixes","odds::string","Iterator of all non-empty prefixes",null,null],[3,"Suffixes","","Iterator of all non-empty suffixes",null,null],[3,"Substrings","","Iterator of all non-empty substrings",null,null],[3,"CharChunks","","An iterator that splits the string in substrings of each `n`\n`char` per substring. The last item will contain the remainder if\n`n` does not divide the char length of the string evenly.",null,null],[3,"CharWindows","","An iterator that produces substrings of each `n`\n`char` per substring in a sliding window that advances one char at a time.",null,null],[3,"CharStr","","A single-char string.",null,null],[8,"StrExt","","Extra methods for `str`",null,null],[10,"rep","","Repeat the string `n` times.",2,null],[10,"append","","Requires `feature=&quot;std&quot;`",2,null],[10,"prefixes","","All non-empty prefixes",2,null],[10,"suffixes","","All non-empty suffixes",2,null],[10,"substrings","","Produce all non-empty substrings",2,null],[10,"is_acceptable_index","","Return `true` if `index` is acceptable for slicing the string.",2,null],[8,"StrSlice","","Extension trait for `str` for string slicing without panicking",null,null],[10,"get_slice","","Return a slice of the string, if it is in bounds /and on character boundaries/,\notherwise return `None`",3,null],[8,"StringExt","","Extra methods for `String`",null,null],[10,"insert_str","","**Panics** if `index` is out of bounds.",4,null],[8,"StrChunksWindows","","Extension traits for the `char_chunks` and `char_windows` methods",null,null],[10,"char_chunks","","Return an iterator that splits the string in substrings of each `n`\n`char` per substring. The last item will contain the remainder if\n`n` does not divide the char length of the string evenly.",5,null],[10,"char_windows","","Return an iterator that produces substrings of each `n`\n`char` per substring in a sliding window that advances one char at a time.",5,null],[11,"clone","","",6,null],[11,"next","","",6,null],[11,"clone","","",7,null],[11,"next","","",7,null],[11,"clone","","",8,null],[11,"next","","",8,null],[11,"clone","","",9,null],[11,"fmt","","",9,null],[11,"next","","",9,null],[11,"clone","","",10,null],[11,"fmt","","",10,null],[11,"next","","",10,null],[11,"clone","","",11,null],[11,"fmt","","",11,null],[11,"new","","Create a new string from `c`.",11,{"inputs":[{"name":"char"}],"output":{"name":"charstr"}}],[11,"deref","","",11,null],[0,"vec","odds","Extensions to `Vec`",null,null],[5,"vec","odds::vec","Create a new vec from the iterable",null,{"inputs":[{"name":"i"}],"output":{"name":"vec"}}],[8,"VecExt","","Extra methods for `Vec&lt;T&gt;`",null,null],[10,"splice","","Remove elements in a range, and insert from an iterator in their place.",12,null],[10,"retain_mut","","Retains only the elements specified by the predicate.",12,null],[8,"VecFindRemove","","",null,null],[16,"Item","","",13,null],[10,"find_remove","","Linear search for the first element equal to `elt` and remove\nit if found.",13,null],[10,"rfind_remove","","Linear search for the last element equal to `elt` and remove\nit if found.",13,null],[0,"slice","odds","Extra functions for slices",null,null],[3,"MendSlices","odds::slice","An iterator adaptor that glues together adjacent contiguous slices.",null,null],[3,"RevSlice","","A reversed view of a slice.",null,null],[5,"shared_prefix","","Return the end index of the longest shared (equal) prefix of `a` and `b`.",null,null],[5,"rotate_left","","Rotate `steps` towards lower indices.",null,null],[5,"split_aligned_for","","Split the input slice into three chunks,\nso that the middle chunk is a slice of a larger &quot;block size&quot;\n(for example T could be u64) that is correctly aligned for `T`.",null,null],[0,"unalign","","",null,null],[3,"UnalignedIter","odds::slice::unalign","An iterator of `T` (by value) where each value read using an\nunaligned load.",null,null],[11,"fmt","","",14,null],[11,"clone","","",14,null],[11,"from_raw_parts","","Create an `UnalignedIter` from `ptr` and `end`, which must be spaced\nan whole number of `T` offsets apart.",14,null],[11,"from_slice","","Create an `UnalignedIter` out of the slice of data, which\niterates first in blocks of `T` (unaligned loads), and\nthen leaves a tail of the remaining bytes.",14,null],[11,"tail","","Return a byte iterator of the remaining tail of the iterator;\nthis can be called at any time, but in particular when the iterator\nhas returned None.",14,null],[11,"has_tail","","Return `true` if the tail is not empty.",14,null],[11,"peek_next","","Return the next iterator element, without stepping the iterator.",14,null],[11,"next","","",14,null],[0,"iter","odds::slice","",null,null],[3,"SliceCopyIter","odds::slice::iter","Slice (contiguous data) iterator.",null,null],[11,"fmt","","",15,null],[11,"clone","","",15,null],[11,"new","","",15,null],[11,"into_raw","","Return the start, end pointer of the iterator",15,null],[11,"next","","",15,null],[11,"size_hint","","",15,null],[11,"count","","",15,null],[11,"last","","",15,null],[11,"next_back","","",15,null],[11,"from","","",15,null],[11,"default","","Create an empty `SliceCopyIter`.",15,{"inputs":[],"output":{"name":"self"}}],[8,"SliceFind","odds::slice","Element-finding methods for slices",null,null],[16,"Item","","",16,null],[10,"find","","Linear search for the first occurrence  `elt` in the slice.",16,null],[10,"rfind","","Linear search for the last occurrence  `elt` in the slice.",16,null],[8,"SliceFindSplit","","Element-finding methods for slices",null,null],[16,"Item","","",17,null],[10,"find_split","","Linear search for the first occurrence  `elt` in the slice.",17,null],[10,"rfind_split","","Linear search for the last occurrence  `elt` in the slice.",17,null],[10,"find_split_mut","","Linear search for the first occurrence  `elt` in the slice.",17,null],[10,"rfind_split_mut","","Linear search for the last occurrence  `elt` in the slice.",17,null],[8,"SliceIterExt","","Extra iterator adaptors for iterators of slice elements.",null,null],[11,"mend_slices","","Return an iterator adaptor that joins together adjacent slices if possible.",18,null],[8,"MendSlice","","A trait for items that can *maybe* be joined together.",null,null],[8,"Pod","","&quot;plain old data&quot;: Types that we can stick arbitrary bit patterns into,\nand thus use them as blocks in `split_aligned_for` or in `UnalignedIter`.",null,null],[11,"find","","",19,null],[11,"rfind","","",19,null],[11,"clone","","",20,null],[11,"new","","Create a new `MendSlices`.",20,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"next","","",20,null],[11,"size_hint","","",20,null],[11,"fmt","","",19,null],[11,"len","","Return the length of the slice.",19,null],[11,"get","","Get element at index `i`.",19,null],[11,"get_mut","","Get element at index `i`.",19,null],[11,"inner_ref","","",19,null],[11,"inner_mut","","",19,null],[11,"into_boxed_slice","","",19,{"inputs":[{"name":"box"}],"output":{"name":"box"}}],[11,"iter","","Return a by-reference iterator",19,null],[11,"iter_mut","","Return a by-mutable-reference iterator",19,null],[11,"split_at","","",19,null],[11,"split_at_mut","","",19,null],[11,"eq","","",19,null],[11,"eq","","",19,null],[11,"hash","","",19,null],[11,"index","","",19,null],[11,"index_mut","","",19,null],[11,"index","","",19,null],[11,"index_mut","","",19,null],[0,"stride","odds","Slice iterator with custom step size",null,null],[3,"Stride","odds::stride","(the stride) skipped per iteration.",null,null],[3,"StrideMut","","The mutable equivalent of Stride.",null,null],[11,"from_ptr_len","","Create a Stride iterator from a raw pointer.",21,null],[11,"from_ptr_len","","Create a StrideMut iterator from a raw pointer.",22,null],[11,"from_slice","","Create Stride iterator from a slice and the element step count.",21,null],[11,"from_stride","","Create Stride iterator from an existing Stride iterator",21,{"inputs":[{"name":"stride"},{"name":"isize"}],"output":{"name":"stride"}}],[11,"swap_ends","","Swap the begin and end and reverse the stride,\nin effect reversing the iterator.",21,null],[11,"len","","Return the number of elements in the iterator.",21,null],[11,"get","","Return a reference to the element of a stride at the\ngiven index, or None if the index is out of bounds.",21,null],[11,"next","","",21,null],[11,"size_hint","","",21,null],[11,"next_back","","",21,null],[11,"index","","Return a reference to the element at a given index.",21,null],[11,"fmt","","",21,null],[11,"from_slice","","Create Stride iterator from a slice and the element step count.",22,null],[11,"from_stride","","Create Stride iterator from an existing Stride iterator",22,{"inputs":[{"name":"stridemut"},{"name":"isize"}],"output":{"name":"stridemut"}}],[11,"swap_ends","","Swap the begin and end and reverse the stride,\nin effect reversing the iterator.",22,null],[11,"len","","Return the number of elements in the iterator.",22,null],[11,"get","","Return a reference to the element of a stride at the\ngiven index, or None if the index is out of bounds.",22,null],[11,"next","","",22,null],[11,"size_hint","","",22,null],[11,"next_back","","",22,null],[11,"index","","Return a reference to the element at a given index.",22,null],[11,"fmt","","",22,null],[11,"clone","","",21,null],[11,"get_mut","","Return a mutable reference to the element of a stride at the\ngiven index, or None if the index is out of bounds.",22,null],[11,"index_mut","","Return a mutable reference to the element at a given index.",22,null],[0,"prelude","odds","prelude of often used traits and functions",null,null],[8,"IndexRange","","**IndexRange** is implemented by Rust&#39;s built-in range types, produced\nby range syntax like `..`, `a..`, `..b` or `c..d`.",null,null],[11,"start","","Start index (inclusive)",23,null],[11,"end","","End index (exclusive)",23,null],[11,"start","","Start index (inclusive)",23,null],[11,"end","","End index (exclusive)",23,null]],"paths":[[3,"Fix"],[3,"EncodeUtf8Error"],[8,"StrExt"],[8,"StrSlice"],[8,"StringExt"],[8,"StrChunksWindows"],[3,"Prefixes"],[3,"Suffixes"],[3,"Substrings"],[3,"CharChunks"],[3,"CharWindows"],[3,"CharStr"],[8,"VecExt"],[8,"VecFindRemove"],[3,"UnalignedIter"],[3,"SliceCopyIter"],[8,"SliceFind"],[8,"SliceFindSplit"],[8,"SliceIterExt"],[3,"RevSlice"],[3,"MendSlices"],[3,"Stride"],[3,"StrideMut"],[8,"IndexRange"]]};
initSearch(searchIndex);
